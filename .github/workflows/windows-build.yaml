name: Build / Openterface Windows Installer

on:
  push:
    branches: ["main", "dev_1223_portable_build"]
    tags: ["v*"]
    paths:
      - '.github/workflows/windows-build.yaml'
      - 'vcpkg.json'
      - 'CMakeLists.txt'
      - '**/*.bat'
      - '**/*.cpp'
  pull_request:
    branches: ["dev"]
    paths:
      - '.github/workflows/windows-build.yaml'
      - 'vcpkg.json'
      - 'CMakeLists.txt'
      - '**/*.bat'
      - '**/*.cpp'
  workflow_dispatch:
    inputs:
      increase_version:
        description: 'Increase the patch version number'
        required: false
        type: boolean
        default: false
      increase_minor:
        description: 'Increase the minor version number'
        required: false
        type: boolean
        default: false
      increase_major:
        description: 'Increase the major version number'
        required: false
        type: boolean
        default: false

defaults:
  run:
    shell: cmd

env:
  SOURCE_DIR: ${{ github.workspace }}
  QT_VERSION: 6.6.3
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  QT_CACHE_KEY: qt-6.6.3-mingw-windows
  JOM_CACHE_KEY: jom-1.1.3-windows
  PACKAGE_DIR: "package_online"
  EXE_NAME: "openterfaceQT.exe"

jobs:
  build:
    runs-on: windows-2022
    permissions:
      contents: write
      actions: write
    environment: ${{ github.event.inputs.TARGET_ENV || 'Openterface_build' }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup MSYS2 MinGW64 environment
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: |
            mingw-w64-x86_64-gcc
            mingw-w64-x86_64-cmake
            mingw-w64-x86_64-nasm
            mingw-w64-x86_64-make
            mingw-w64-x86_64-pkgconf
            mingw-w64-x86_64-zlib
            mingw-w64-x86_64-bzip2
            mingw-w64-x86_64-xz
            mingw-w64-x86_64-libjpeg-turbo
            mingw-w64-x86_64-libiconv
            mingw-w64-x86_64-libmfx
            mingw-w64-x86_64-libusb
            diffutils
            make
            libtool
            git
            perl

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Update version
        run: |
          if [ "${{ github.event.inputs.increase_version }}" = "true" ]; then
            python "${{ env.SOURCE_DIR }}/build-script/update_version.py" --increase-version
          elif [ "${{ github.event.inputs.increase_major }}" = "true" ]; then
            python "${{ env.SOURCE_DIR }}/build-script/update_version.py" --increase-major
          elif [ "${{ github.event.inputs.increase_minor }}" = "true" ]; then
            python "${{ env.SOURCE_DIR }}/build-script/update_version.py" --increase-minor
          else
            python "${{ env.SOURCE_DIR }}/build-script/update_version.py"
          fi
        shell: bash

      - name: Commit and push version bump
        if: ${{ github.event.inputs.increase_version == 'true' || github.event.inputs.increase_minor == 'true' || github.event.inputs.increase_major == 'true' }}
        shell: bash
        run: |
          echo "Committing updated version.h and creating tag v$NEW_VERSION"
          git status --porcelain
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add resources/version.h
          git commit -m "Bump version to $NEW_VERSION" || echo "No changes to commit"
          # Create annotated tag if it doesn't already exist
          if ! git rev-parse "refs/tags/v$NEW_VERSION" >/dev/null 2>&1; then
            git tag -a "v$NEW_VERSION" -m "Release $NEW_VERSION"
          else
            echo "Tag v$NEW_VERSION already exists, skipping tag creation"
          fi
          # Push branch and tags back to origin
          git push origin "HEAD:${{ github.ref_name }}" --follow-tags || echo "Push failed; check permissions or branch protection"

      - name: Dispatch Linux build (on patch increment)
        if: ${{ github.event.inputs.increase_version == 'true' }}
        shell: bash
        run: |
          echo "Dispatching linux-build.yml workflow via REST API"
          curl -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/linux-build.yaml/dispatches \
            -d "{\"ref\":\"${{ github.ref_name }}\",\"inputs\":{\"build_type\":\"both\",\"ubuntu_version\":\"22.04\"}}"

      - name: Dispatch Windows Portable build (on patch increment)
        if: ${{ github.event.inputs.increase_version == 'true' }}
        shell: bash
        run: |
          echo "Dispatching windows-portable-build.yaml workflow via REST API"
          curl -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/windows-portable-build.yaml/dispatches \
            -d "{\"ref\":\"${{ github.ref_name }}\"}"

      - name: Get all tags for correct version determination
        working-directory: ${{ github.workspace }}
        run: |
          git fetch --all --tags -f

      - name: Install Qt
        uses: jurplel/install-qt-action@v4
        with:
          version: ${{ env.QT_VERSION }}
          host: windows
          target: desktop
          arch: win64_mingw
          dir: ${{ runner.temp }}
          modules: qtmultimedia qtserialport qtimageformats
          setup-python: false

      - name: Cache FFmpeg (shared)
        id: cache-ffmpeg
        uses: actions/cache@v4
        with:
          path: C:\ffmpeg-shared
          key: ffmpeg-shared-6.1.1-windows-v1-${{ hashFiles('.github/workflows/windows-build.yaml') }}
          restore-keys: |
            ffmpeg-shared-6.1.1-windows-v1-

      - name: Check Build Scripts Available
        shell: cmd
        run: |
          echo "Checking available build scripts..."
          cd /d "${{ env.SOURCE_DIR }}"
          dir build-script\*.bat
          dir build-script\*.sh

      - name: Build Shared FFmpeg (using MSYS2 MinGW64)
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        shell: msys2 {0}
        run: |
          echo "Building shared FFmpeg using MSYS2 MinGW64..."
          export SKIP_MSYS_MINGW=1
          export EXTERNAL_MINGW_MSYS="/mingw64"
          export FFMPEG_INSTALL_PREFIX="/c/ffmpeg-shared"
          # Ensure pkg-config can find MinGW pkgconfig
          export PKG_CONFIG_PATH="/mingw64/lib/pkgconfig:$PKG_CONFIG_PATH"

          export ENABLE_NVENC=1

          export AUTO_INSTALL_FFNV=1

          export ENABLE_LIBMFX=1

          cd "${{ env.SOURCE_DIR }}/build-script"
          ./build-shared-ffmpeg-windows.sh > "${{ github.workspace }}/ffmpeg_build.log" 2>&1
          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            echo "ERROR: FFmpeg build failed!"
            tail -n 200 "${{ github.workspace }}/ffmpeg_build.log" || true
            exit $EXIT_CODE
          fi
          echo "FFmpeg build succeeded"

      - name: Verify FFmpeg installation
        shell: msys2 {0}
        run: |
          if [ -f "/c/ffmpeg-shared/bin/avcodec-60.dll" ]; then
            echo "✓ FFmpeg DLLs found"
          else
            echo "✗ FFmpeg DLLs missing"
            ls -la "/c/ffmpeg-shared/bin/" || echo "FFmpeg bin directory does not exist"
            exit 1
          fi
          if [ -f "/c/ffmpeg-shared/lib/libavcodec.dll.a" ]; then
            echo "✓ FFmpeg import libraries found"
          else
            echo "✗ FFmpeg import libraries missing"
            ls -la "/c/ffmpeg-shared/lib/" || echo "FFmpeg lib directory does not exist"
            exit 1
          fi

      - name: Verify FFmpeg hwaccel and mjpeg decoders
        shell: msys2 {0}
        run: |
          echo "=== FFmpeg hardware acceleration summary ==="
          /c/ffmpeg-shared/bin/ffmpeg -hide_banner -hwaccels || echo "ffmpeg not found or hwaccels failed"
          echo ""
          echo "=== MJPEG decoders ==="
          /c/ffmpeg-shared/bin/ffmpeg -hide_banner -decoders | grep -i mjpeg || echo "No mjpeg decoders found"
          echo ""
          echo "=== NVENC/QSV specific checks ==="
          /c/ffmpeg-shared/bin/ffmpeg -hide_banner -decoders | grep -E "(cuvid|qsv)" || echo "No NVENC/QSV decoders found"
          echo ""
          echo "=== Tail of configure log (if present) ==="
          if [ -f "${{ env.SOURCE_DIR }}/build-script/ffmpeg-build-temp/ffmpeg-configure.log" ]; then
            tail -n 200 "${{ env.SOURCE_DIR }}/build-script/ffmpeg-build-temp/ffmpeg-configure.log" || true
          else
            echo "Configure log not found"
          fi

      - name: Upload FFmpeg configure log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-configure-log
          path: ${{ env.SOURCE_DIR }}/build-script/ffmpeg-build-temp/ffmpeg-configure.log
          if-no-files-found: warn

      - name: Cache LibUSB
        id: cache-libusb
        uses: actions/cache@v4
        with:
          path: C:\libusb
          key: libusb-1.0.27-windows-v1
          restore-keys: |
            libusb-1.0.27-windows-v1

      - name: Verify and Setup LibUSB
        if: steps.cache-libusb.outputs.cache-hit != 'true' || github.event.inputs.force_rebuild == 'true'
        shell: msys2 {0}
        run: |
          echo "Setting up LibUSB for Qt/MinGW compatibility..."
          
          # First check if MinGW LibUSB was installed
          echo "Checking MinGW LibUSB installation..."
          ls -la /mingw64/bin/*usb* || echo "No MinGW LibUSB DLLs found"
          ls -la /mingw64/lib/*usb* || echo "No MinGW LibUSB libraries found"
          
          # MinGW64 is primary; no UCRT64 backup checks
          echo "Checking MinGW64 LibUSB installation..."
          ls -la /mingw64/bin/*usb* || echo "No MinGW LibUSB DLLs found"
          ls -la /mingw64/lib/*usb* || echo "No MinGW LibUSB libraries found"
          
          # Check installed packages
          pacman -Q | grep -i usb || echo "No USB packages installed"
          
          # Verify pkg-config for MinGW64
          echo "Checking pkg-config..."
          PKG_CONFIG_PATH="/mingw64/lib/pkgconfig:$PKG_CONFIG_PATH" pkg-config --exists libusb-1.0 && echo "✓ LibUSB pkg-config found" || {
            echo "✗ LibUSB pkg-config not found, trying to install MinGW version..."
            pacman -S --needed --noconfirm mingw-w64-x86_64-libusb
          }
          
          # Create cache directory structure
          mkdir -p /c/libusb/bin /c/libusb/lib /c/libusb/include
          
          # Priority: MinGW LibUSB (better Qt compatibility)
          LIBUSB_FOUND=false
          
          # Try MinGW version first (better ABI compatibility with Qt)
          if [ -f "/mingw64/bin/libusb-1.0.dll" ]; then
            echo "✓ Found MinGW libusb-1.0.dll (preferred for Qt compatibility)"
            cp /mingw64/bin/libusb-1.0.dll /c/libusb/bin/
            cp /mingw64/bin/libusb-1.0.dll /c/libusb/bin/msys-usb-1.0.dll
            echo "✓ Created msys-usb-1.0.dll from MinGW libusb-1.0.dll"
            LIBUSB_FOUND=true
            
            # Copy MinGW runtime dependencies that might be needed
            cp /mingw64/bin/libgcc_s_dw2-1.dll /c/libusb/bin/ 2>/dev/null || echo "MinGW libgcc_s_dw2-1.dll not found"
            cp /mingw64/bin/libwinpthread-1.dll /c/libusb/bin/ 2>/dev/null || echo "MinGW libwinpthread-1.dll not found"
            
          else
            echo "✗ No LibUSB DLL found in MinGW64"
          fi
          
          # Copy library and header files
          cp /mingw64/lib/*usb* /c/libusb/lib/ 2>/dev/null || echo "No USB libs to copy"
          cp -r /mingw64/include/libusb* /c/libusb/include/ 2>/dev/null || echo "No USB headers to copy"
          
          # Final verification
          echo "Final LibUSB cache contents:"
          ls -la /c/libusb/bin/ || echo "No files in cache bin"
          
          if [ "$LIBUSB_FOUND" = "true" ]; then
            echo "✓ LibUSB setup completed successfully"
          else
            echo "✗ LibUSB setup failed"
          fi

      - name: Upload FFmpeg Build Log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-build-log
          path: ${{ github.workspace }}/ffmpeg_build.log
          if-no-files-found: warn

      - name: Upload LibUSB Build Log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: libusb-build-log
          path: ${{ github.workspace }}/libusb_build.log
          if-no-files-found: warn

      - name: Dump FFmpeg and LibUSB logs (tail)
        if: always()
        shell: pwsh
        run: |
          if (Test-Path "$env:GITHUB_WORKSPACE\ffmpeg_build.log") { Write-Host "---- FFmpeg tail (last 200 lines) ----"; Get-Content "$env:GITHUB_WORKSPACE\ffmpeg_build.log" -Tail 200 } else { Write-Host "No ffmpeg_build.log" }
          if (Test-Path "$env:GITHUB_WORKSPACE\libusb_build.log") { Write-Host "---- LibUSB tail (last 200 lines) ----"; Get-Content "$env:GITHUB_WORKSPACE\libusb_build.log" -Tail 200 } else { Write-Host "No libusb_build.log" }

      - name: Create build directory
        run: mkdir ${{ runner.temp }}\build

      - name: Build
        working-directory: ${{ runner.temp }}\build
        shell: msys2 {0}
        run: |
          echo "Setting up build environment..."
          # Convert Windows paths to MSYS2 format
          SOURCE_DIR_MSYS="/$(echo '${{ env.SOURCE_DIR }}' | sed 's|\\|/|g' | sed 's|:||')"
          QT_PATH_MSYS="/$(echo '${{ runner.temp }}/Qt/6.6.3/mingw_64/bin' | sed 's|\\|/|g' | sed 's|:||')"
          
          # Add Qt tools to PATH for MSYS2 environment
          export PATH="/mingw64/bin:${QT_PATH_MSYS}:$PATH"
          echo "Updated PATH: $PATH"
          echo "Source directory (MSYS2 format): $SOURCE_DIR_MSYS"
          
          echo "Checking Qt tools availability..."
          which lupdate || echo "lupdate not found in PATH"
          which lrelease || echo "lrelease not found in PATH"
          
          echo "Updating translations with lupdate..."
          lupdate "${SOURCE_DIR_MSYS}/openterfaceQT.pro"
          echo "Generating .qm files with lrelease..."
          lrelease "${SOURCE_DIR_MSYS}/openterfaceQT.pro"
          
          echo "Configuring with CMake..."
          cmake -G "MinGW Makefiles" \
            -DCMAKE_BUILD_TYPE=Release \
            -DFFMPEG_PREFIX=C:/ffmpeg-shared \
            -DUSE_SHARED_FFMPEG=ON \
            -DHAVE_LIBJPEG_TURBO=ON \
            "$SOURCE_DIR_MSYS"
          echo "Building with mingw32-make..."
          mingw32-make -j2
          if [ ! -f openterfaceQT.exe ]; then
            echo "Error: Failed to build openterfaceQT.exe"
            exit 1
          fi
          echo "Build directory contents:"
          ls -la
          # ... rest of packaging steps (copy files, etc.)
          mkdir -p ${{ env.PACKAGE_DIR }}/driver/windows
          mkdir -p ${{ env.PACKAGE_DIR }}/config/languages
          mkdir -p ${{ env.PACKAGE_DIR }}/config/keyboards
          cp openterfaceQT.exe ${{ env.PACKAGE_DIR }}/${{ env.EXE_NAME }}
          cp "${SOURCE_DIR_MSYS}/LICENSE" ${{ env.PACKAGE_DIR }}
          cp "${SOURCE_DIR_MSYS}/driver/windows/"* ${{ env.PACKAGE_DIR }}/driver/windows/
          echo "Copying FFmpeg DLLs..."
          cp /c/ffmpeg-shared/bin/av*.dll ${{ env.PACKAGE_DIR }}
          cp /c/ffmpeg-shared/bin/sw*.dll ${{ env.PACKAGE_DIR }}
          cp /c/ffmpeg-shared/bin/postproc-57.dll ${{ env.PACKAGE_DIR }} || echo "Warning: postproc-57.dll not found"
          cp /c/ffmpeg-shared/bin/libturbojpeg.dll ${{ env.PACKAGE_DIR }}
          echo "Copying LibUSB DLLs..."
          LIBUSB_FOUND=false
          
          # Priority 1: Check cache for MinGW-compatible LibUSB
          if [ -f "/c/libusb/bin/msys-usb-1.0.dll" ]; then
            cp /c/libusb/bin/msys-usb-1.0.dll ${{ env.PACKAGE_DIR }}
            echo "✓ Copied msys-usb-1.0.dll from cache"
            LIBUSB_FOUND=true
          elif [ -f "/c/libusb/bin/libusb-1.0.dll" ]; then
            cp /c/libusb/bin/libusb-1.0.dll ${{ env.PACKAGE_DIR }}
            cp /c/libusb/bin/libusb-1.0.dll ${{ env.PACKAGE_DIR }}/msys-usb-1.0.dll
            echo "✓ Copied libusb-1.0.dll and created msys-usb-1.0.dll from cache"
            LIBUSB_FOUND=true
          fi
          
          # Priority 2: Check MinGW64 directly (best ABI compatibility with Qt)
          if [ "$LIBUSB_FOUND" = "false" ] && [ -f "/mingw64/bin/libusb-1.0.dll" ]; then
            cp /mingw64/bin/libusb-1.0.dll ${{ env.PACKAGE_DIR }}
            cp /mingw64/bin/libusb-1.0.dll ${{ env.PACKAGE_DIR }}/msys-usb-1.0.dll
            echo "✓ Copied MinGW libusb-1.0.dll and created msys-usb-1.0.dll (best compatibility)"
            
            # Copy MinGW runtime dependencies to prevent ABI mismatches
            cp /mingw64/bin/libgcc_s_dw2-1.dll ${{ env.PACKAGE_DIR }} 2>/dev/null || echo "MinGW libgcc_s_dw2-1.dll not needed"
            cp /mingw64/bin/libwinpthread-1.dll ${{ env.PACKAGE_DIR }} 2>/dev/null && echo "✓ Copied MinGW pthread" || echo "MinGW pthread not needed"
            LIBUSB_FOUND=true
            
          # No UCRT64 fallback (MinGW64 only)
          fi
          
          # Copy additional MinGW runtime DLLs that may be needed for LibUSB compatibility
          if [ "$LIBUSB_FOUND" = "true" ]; then
            echo "Ensuring runtime compatibility..."
            # Note: Qt is built with MinGW, so ensure MinGW runtimes are present when using LibUSB
            for dll in libgcc_s_dw2-1.dll libwinpthread-1.dll; do
              if [ -f "/mingw64/bin/$dll" ] && [ ! -f "${{ env.PACKAGE_DIR }}/$dll" ]; then
                cp "/mingw64/bin/$dll" ${{ env.PACKAGE_DIR }} && echo "✓ Copied MinGW runtime $dll"
              fi
            done
          fi
          
          # Final comprehensive search if still not found
          if [ "$LIBUSB_FOUND" = "false" ]; then
            echo "⚠ LibUSB DLL not found in preferred locations, searching comprehensively..."
            USB_DLLS=$(find /mingw64 -name "*usb*.dll" 2>/dev/null | head -5)
            if [ -n "$USB_DLLS" ]; then
              echo "Found USB DLLs: $USB_DLLS"
              for dll in $USB_DLLS; do
                dll_name=$(basename "$dll")
                cp "$dll" ${{ env.PACKAGE_DIR }}/
                if [ "$dll_name" = "libusb-1.0.dll" ]; then
                  cp "$dll" ${{ env.PACKAGE_DIR }}/msys-usb-1.0.dll
                  echo "✓ Created msys-usb-1.0.dll from found $dll_name"
                fi
                echo "✓ Copied $dll_name from $(dirname "$dll")"
                LIBUSB_FOUND=true
              done
            fi
          fi
          
          if [ "$LIBUSB_FOUND" = "false" ]; then
            echo "✗ LibUSB DLL not found. Application will likely fail at runtime."
            echo "This may cause heap corruption errors (c0000374)."
          else
            echo "✓ LibUSB DLL setup completed"
          fi
          echo "Copying MSYS2 runtime dependencies..."
          cp /mingw64/bin/libiconv-2.dll ${{ env.PACKAGE_DIR }} || echo "Warning: libiconv-2.dll not found"
          cp /mingw64/bin/libbz2-1.dll ${{ env.PACKAGE_DIR }} || echo "Warning: libbz2-1.dll not found"
          cp /mingw64/bin/liblzma-5.dll ${{ env.PACKAGE_DIR }} || echo "Warning: liblzma-5.dll not found"
          cp /mingw64/bin/zlib1.dll ${{ env.PACKAGE_DIR }} || echo "Warning: zlib1.dll not found"
          cp /mingw64/bin/libwinpthread-1.dll ${{ env.PACKAGE_DIR }} || echo "Warning: libwinpthread-1.dll not found"
          cp /mingw64/bin/libgcc_s_seh-1.dll ${{ env.PACKAGE_DIR }} || echo "Warning: libgcc_s_seh-1.dll not found"
          cp /mingw64/bin/libstdc++-6.dll ${{ env.PACKAGE_DIR }} || echo "Warning: libstdc++-6.dll not found"
          echo "Copying translation & keyboard layouts files..."
          cp "${SOURCE_DIR_MSYS}/config/keyboards/"*.json ${{ env.PACKAGE_DIR }}/config/keyboards/
          cp "${SOURCE_DIR_MSYS}/config/languages/"*.qm ${{ env.PACKAGE_DIR }}/config/languages/
          echo "Running windeployqt..."
          cd ${{ env.PACKAGE_DIR }}
          # Note: windeployqt is a Windows executable, so we need to call it from cmd
          # We'll switch back to cmd shell for this step

      - name: Run windeployqt (Windows native tool)
        working-directory: ${{ runner.temp }}\build\${{ env.PACKAGE_DIR }}
        run: |
          windeployqt ${{ env.EXE_NAME }} --compiler-runtime --multimedia --network

      - name: Verify DLL dependencies
        working-directory: ${{ runner.temp }}\build\${{ env.PACKAGE_DIR }}
        shell: msys2 {0}
        run: |
          echo "=== DLL Dependency Analysis ==="
          echo "Checking all DLLs in package..."
          ls -la *.dll || true
          
          echo ""
          echo "=== Checking openterfaceQT.exe dependencies ==="
          if command -v objdump >/dev/null 2>&1; then
            echo "Using objdump to check dependencies:"
            objdump -p openterfaceQT.exe | grep -i "DLL Name" || true
          fi
          
          echo ""
          echo "=== Checking for LibUSB dependencies ==="
          ldd openterfaceQT.exe | grep -i usb || echo "No USB dependencies found in ldd output"
          
          echo ""
          echo "=== Runtime Library Compatibility Check ==="
          # Check for potential ABI conflicts
          echo "Checking Qt DLLs..."
          ls -la Qt*.dll | head -5 || echo "No Qt DLLs found"
          
          echo "Checking MSYS2 runtime DLLs..."
          for dll in libgcc_s_seh-1.dll libstdc++-6.dll libwinpthread-1.dll libgcc_s_dw2-1.dll; do
            if [ -f "$dll" ]; then
              echo "✓ Found $dll"
              # Check DLL info using objdump
              if command -v objdump >/dev/null 2>&1; then
                echo "  Architecture: $(objdump -f "$dll" | grep "^architecture" || echo "unknown")"
              fi
            else
              echo "✗ Missing $dll"
            fi
          done
          
          echo ""
          echo "=== LibUSB DLL Analysis ==="
          for dll in libusb-1.0.dll msys-usb-1.0.dll; do
            if [ -f "$dll" ]; then
              echo "✓ Found $dll"
              if command -v objdump >/dev/null 2>&1; then
                echo "  Architecture: $(objdump -f "$dll" | grep "^architecture" || echo "unknown")"
                echo "  Imports: $(objdump -p "$dll" | grep -i "DLL Name" | wc -l) DLLs"
              fi
            else
              echo "✗ Missing $dll"
            fi
          done
          
          echo ""
          echo "=== Potential ABI Compatibility Issues ==="
          # Check if we're mixing different compiler runtimes
          echo "Checking for mixed runtime libraries..."
          
          # Check for MinGW libraries only
          echo "MinGW64 DLLs:"
          ls -la /mingw64/bin/*.dll 2>/dev/null | head -10 || echo "No MinGW64 DLLs found"
          
          echo "Qt DLLs:"
          ls -la Qt*.dll 2>/dev/null | head -3 || echo "No Qt DLLs found"
          
          echo "Qt DLLs:"
          ls -la Qt*.dll 2>/dev/null | head -3 || echo "No Qt DLLs found"
          
          echo ""
          echo "=== Debug Diagnostics (optional) ==="
          if [ "${{ github.event.inputs.collect_debug }}" = "true" ]; then
            echo "Collecting debug build and gdb backtrace..."
            mkdir -p ${RUNNER_TEMP}/build-debug
            cd ${RUNNER_TEMP}/build-debug
            cmake -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Debug -DFFMPEG_PREFIX=C:/ffmpeg-shared -DUSE_SHARED_FFMPEG=ON "${{ env.SOURCE_DIR_MSYS }}"
            mingw32-make -j2 || echo "Debug build failed"
            if [ -f openterfaceQT.exe ]; then
              echo "Running gdb to capture backtrace..."
              gdb --batch -ex "set pagination 0" -ex "run" -ex "thread apply all bt full" --args ./openterfaceQT.exe > "${{ github.workspace }}/gdb_bt.log" 2>&1 || true
            else
              echo "Debug executable not found; skipping gdb run"
            fi
            echo "Collecting objdump info for package DLLs..."
            mkdir -p "${{ github.workspace }}/dll_info"
            for f in *.dll ${RUNNER_TEMP}/build-debug/*.dll ${RUNNER_TEMP}/build/${{ env.PACKAGE_DIR }}/*.dll ${RUNNER_TEMP}/build/${{ env.PACKAGE_DIR }}/*/*.dll; do
              if [ -f "$f" ]; then
                base=$(basename "$f")
                objdump -p "$f" > "${{ github.workspace }}/dll_info/${base}.objdump.txt" 2>&1 || true
              fi
            done
          else
            echo "collect_debug not enabled; skipping debug diagnostics"
          fi
          
          echo ""
          echo "=== Recommendation ==="
          echo "If the application crashes with heap corruption (c0000374):"
          echo "1. Ensure all DLLs use the same runtime (MinGW64 preferred for Qt)"
          echo "2. Check for missing or mismatched Qt platform plugins"
          echo "3. Verify LibUSB is compatible with the Qt/MinGW runtime"
          echo "4. Run the application under gdb to collect a backtrace (enable collect_debug input)"
          echo ""
          echo "Verification complete"

      - name: Upload gdb backtrace
        if: github.event.inputs.collect_debug == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: gdb-backtrace
          path: ${{ github.workspace }}\gdb_bt.log
          if-no-files-found: warn

      - name: Upload DLL info (objdump outputs)
        if: github.event.inputs.collect_debug == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: dll-info
          path: ${{ github.workspace }}\dll_info
          if-no-files-found: warn

      - name: Inspect Output and package directories
        shell: pwsh
        run: |
          Write-Host "Listing Output directory: $env:SOURCE_DIR\Output"
          if (Test-Path "$env:SOURCE_DIR\Output") { Get-ChildItem "$env:SOURCE_DIR\Output" -Recurse -Force | Select-Object -First 200 } else { Write-Host "Output directory not found" }
          Write-Host "Listing package directory: $env:SOURCE_DIR\$env:PACKAGE_DIR"
          if (Test-Path "$env:SOURCE_DIR\$env:PACKAGE_DIR") { Get-ChildItem "$env:SOURCE_DIR\$env:PACKAGE_DIR" -Recurse -Force | Select-Object -First 200 } else { Write-Host "Package directory not found" }

      - name: Upload Output folder
        uses: actions/upload-artifact@v4
        with:
          name: output-folder
          path: ${{ env.SOURCE_DIR }}\Output
          if-no-files-found: warn

      - name: Install NSIS (if missing)
        shell: pwsh
        run: |
          if (-not (Get-Command makensis -ErrorAction SilentlyContinue)) {
            Write-Host "makensis not found; installing NSIS via Chocolatey..."
            choco install nsis -y
          } else {
            Write-Host "makensis already available"
          }

      - name: Compile .NSI to .EXE Installer
        shell: pwsh
        run: |
          Write-Host "Compiling NSIS installer..."
          $pkg = "${{ runner.temp }}\build\${{ env.PACKAGE_DIR }}"
          if (-not (Test-Path $pkg)) {
            Write-Host "Package dir not found: $pkg"; exit 1
          }
          New-Item -ItemType Directory -Path "${{ env.SOURCE_DIR }}\Output" -Force | Out-Null
          # Run makensis with defines used by installer script
          & makensis /DWorkingDir="$pkg" /DMyAppVersion="${{ env.NEW_VERSION }}" /DMyAppPublisher="${{ vars.MY_APP_PUBLISHER }}" /DMyAppURL="${{ vars.MY_APP_URL }}" /DOutputDir="${{ env.SOURCE_DIR }}\Output" /DOutputBaseFileName=openterfaceQT.windows.amd64.installer /DMyAppExeName=${{ env.EXE_NAME }} "${{ env.SOURCE_DIR }}\installer.nsi"
          if ($LASTEXITCODE -ne 0) { Write-Host "makensis failed with exit code $LASTEXITCODE"; exit $LASTEXITCODE }
          Write-Host "Installer build completed. Listing Output directory:"
          Get-ChildItem "${{ env.SOURCE_DIR }}\Output" -Recurse | Select-Object -First 200

      - name: Upload windows installer
        uses: actions/upload-artifact@v4
        with:
          name: openterfaceQT_windows_amd64_installer
          path: ${{ env.SOURCE_DIR }}\Output\*.exe
          if-no-files-found: error

      - name: Copy package to workspace for inspection (optional)
        shell: pwsh
        run: |
          $src = "${{ runner.temp }}\build\${{ env.PACKAGE_DIR }}"
          $dst = "${{ env.SOURCE_DIR }}\${{ env.PACKAGE_DIR }}"
          if (Test-Path $src) {
            Remove-Item -Recurse -Force $dst -ErrorAction SilentlyContinue || true
            Copy-Item -Recurse -Force $src $dst
            Write-Host "Copied package to workspace: $dst"
          } else {
            Write-Host "Package dir not found: $src"
          }

