name: Docker Test - Openterface Shared Build

on:
  push:
    branches: ["main", "dev"]
    paths:
      - 'docker/testos/Dockerfile.ubuntu-test-shared'
      - 'docker/install-openterface.sh'
      - 'docker/screenshot-docker-app.sh'
      - 'docker/entrypoint.sh'
      - '.github/workflows/docker-test.yaml'
      - 'packaging/debian/**'
  pull_request:
    branches: ["main", "dev"]
    paths:
      - 'docker/testos/Dockerfile.ubuntu-test-shared'
      - 'docker/install-openterface.sh'
      - '.github/workflows/docker-test.yaml'
  workflow_run:
    workflows: ["Linux Build"]
    types:
      - completed
  workflow_dispatch:

env:
  DOCKER_IMAGE_SHARED: openterface-test-shared
  DOCKER_TAG: test-${{ github.sha }}

jobs:
  build-test-shared:
    strategy:
      matrix:
        install_type: ['deb', 'appimage']
    runs-on: ubuntu-24.04
    timeout-minutes: 60
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set default install_type for non-workflow_dispatch triggers
        run: |
          # Set install_type from matrix
          echo "INSTALL_TYPE=${{ matrix.install_type }}" >> $GITHUB_ENV
          echo "â„¹ï¸ Using install_type: ${{ matrix.install_type }}"
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Download Latest Linux Build Artifacts
        run: |
          echo "ï¿½ Downloading latest Linux shared build artifacts..."
          
          # Create build directory
          mkdir -p build
          
          # Get the latest successful linux-build workflow run
          LATEST_RUN=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/linux-build.yaml/runs?status=success&head_branch=${{ github.ref_name }}" \
            | jq -r '.workflow_runs[0]')
          
          if [ "$LATEST_RUN" = "null" ] || [ -z "$LATEST_RUN" ]; then
            echo "âš ï¸ No successful linux-build runs found for branch ${{ github.ref_name }}"
            echo "Trying to get from main branch..."
            LATEST_RUN=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/linux-build.yaml/runs?status=success&head_branch=main" \
              | jq -r '.workflow_runs[0]')
          fi
          
          if [ "$LATEST_RUN" = "null" ] || [ -z "$LATEST_RUN" ]; then
            echo "âŒ No successful linux-build runs found"
            exit 1
          fi
          
          RUN_ID=$(echo "$LATEST_RUN" | jq -r '.id')
          echo "âœ… Found latest linux-build run: $RUN_ID"
          
          # Get all artifacts from this run
          ARTIFACTS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts")
          
          # Find and download the appropriate artifact based on install_type
          if [ "${{ env.INSTALL_TYPE }}" = "deb" ]; then
            ARTIFACT_PATTERN="shared.deb"
          elif [ "${{ env.INSTALL_TYPE }}" = "appimage" ]; then
            ARTIFACT_PATTERN="shared.AppImage"
          else
            echo "âŒ Invalid install_type: ${{ env.INSTALL_TYPE }}"
            exit 1
          fi
          
          ARTIFACT_ID=$(echo "$ARTIFACTS" | jq -r '.artifacts[] | select(.name | contains("'$ARTIFACT_PATTERN'")) | .id' | head -1)
          
          if [ -z "$ARTIFACT_ID" ] || [ "$ARTIFACT_ID" = "null" ]; then
            echo "âŒ No shared artifact matching pattern '$ARTIFACT_PATTERN' found in latest build"
            echo "Available artifacts:"
            echo "$ARTIFACTS" | jq -r '.artifacts[].name'
            exit 1
          fi
          
          echo "ðŸ“¦ Found artifact: $ARTIFACT_ID"
          
          # Download the artifact
          echo "â¬‡ï¸ Downloading artifact..."
          curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -o artifact.zip \
            "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip"
          
          # Extract the artifact file
          unzip -j artifact.zip -d build/
          
          # Verify the correct file was extracted based on install_type
          if [ "${{ env.INSTALL_TYPE }}" = "deb" ]; then
            if ls build/*.deb 1> /dev/null 2>&1; then
              echo "âœ… DEB package extracted successfully"
              ls -lh build/*.deb
            else
              echo "âŒ Failed to extract DEB package"
              exit 1
            fi
          elif [ "${{ env.INSTALL_TYPE }}" = "appimage" ]; then
            if ls build/*.AppImage 1> /dev/null 2>&1; then
              echo "âœ… AppImage extracted successfully"
              ls -lh build/*.AppImage
            else
              echo "âŒ Failed to extract AppImage package"
              exit 1
            fi
          fi
          
          echo "ðŸ“¦ Build artifacts ready in ./build directory:"
          ls -la build/
      - name: Build Docker image (Shared)
        run: |
          echo "ðŸ”¨ Building Docker image: ${{ env.DOCKER_IMAGE_SHARED }}:${{ env.DOCKER_TAG }}"
          
          docker build \
            -f docker/testos/Dockerfile.ubuntu-test-shared \
            --build-arg INSTALL_TYPE=${{ env.INSTALL_TYPE }} \
            -t ${{ env.DOCKER_IMAGE_SHARED }}:${{ env.DOCKER_TAG }} \
            docker/
          
          echo "ðŸ“¦ Docker image built successfully"
          echo "Note: Build artifacts will be passed at runtime if available"

      - name: Prepare volume mounts for build artifacts
        run: |
          echo "ðŸ“¦ Checking for build artifacts to mount..."
          
          # Determine artifact pattern based on install type
          if [ "${{ env.INSTALL_TYPE }}" = "deb" ]; then
            ARTIFACT_PATTERN="*.deb"
            ARTIFACT_TYPE="DEB"
          elif [ "${{ env.INSTALL_TYPE }}" = "appimage" ]; then
            ARTIFACT_PATTERN="*.AppImage"
            ARTIFACT_TYPE="AppImage"
          fi
          
          # Check if we have the appropriate build artifacts to mount
          if [ -d build ] && [ -n "$(find build -name "$ARTIFACT_PATTERN" 2>/dev/null)" ]; then
            echo "âœ… Found $ARTIFACT_TYPE build artifacts"
            VOLUME_MOUNT="-v $(pwd)/build:/tmp/build-artifacts:ro"
            echo "VOLUME_MOUNT=$VOLUME_MOUNT" >> $GITHUB_ENV
            echo "HAS_VOLUME_MOUNT=true" >> $GITHUB_ENV
            ls -lh build/
          else
            echo "â„¹ï¸ No $ARTIFACT_TYPE build artifacts found (will download from GitHub)"
            echo "VOLUME_MOUNT=" >> $GITHUB_ENV
            echo "HAS_VOLUME_MOUNT=false" >> $GITHUB_ENV
          fi
          
          # Pass GITHUB_TOKEN to Docker containers for artifact downloads
          echo "GITHUB_TOKEN_ENV=-e GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_ENV

      - name: Verify Docker image (Shared)
        run: |
          echo "ï¿½?Verifying Docker image was built successfully"
          docker images | grep ${{ env.DOCKER_IMAGE_SHARED }}
          
          echo "ðŸ“Š Image information:"
          docker inspect ${{ env.DOCKER_IMAGE_SHARED }}:${{ env.DOCKER_TAG }} --format='{{.Config.Env}}'
          docker inspect ${{ env.DOCKER_IMAGE_SHARED }}:${{ env.DOCKER_TAG }} --format='{{.Config.User}}'
          docker inspect ${{ env.DOCKER_IMAGE_SHARED }}:${{ env.DOCKER_TAG }} --format='{{.Config.WorkingDir}}'
          
          echo "ðŸ” Image CMD and Entrypoint:"
          docker inspect ${{ env.DOCKER_IMAGE_SHARED }}:${{ env.DOCKER_TAG }} --format='{{.Config.Cmd}}'
          docker inspect ${{ env.DOCKER_IMAGE_SHARED }}:${{ env.DOCKER_TAG }} --format='{{.Config.Entrypoint}}'
          
          echo "ðŸ” Image layers (last 10):"
          docker history ${{ env.DOCKER_IMAGE_SHARED }}:${{ env.DOCKER_TAG }} | head -10

      - name: Show all included libraries in AppImage (Shared)
        if: matrix.install_type == 'appimage'
        run: |
          echo "ðŸ“š Analyzing AppImage included libraries"
          
          # Find the AppImage file with absolute path
          APPIMAGE=$(find build -name "*.AppImage" -type f | head -1)
          
          if [ -z "$APPIMAGE" ] || [ ! -f "$APPIMAGE" ]; then
            echo "âš ï¸ AppImage file not found in build directory"
            echo "Available files:"
            ls -la build/
            exit 1
          fi
          
          # Convert to absolute path
          APPIMAGE=$(cd "$(dirname "$APPIMAGE")" && pwd)/$(basename "$APPIMAGE")
          
          echo "Found AppImage: $APPIMAGE"
          echo "File size: $(ls -lh "$APPIMAGE" | awk '{print $5}')"
          echo ""
          
          # Extract AppImage contents without mounting
          echo "ðŸ“‚ Extracting AppImage contents:"
          echo "==============================="
          
          EXTRACT_DIR=$(mktemp -d)
          trap "rm -rf $EXTRACT_DIR" EXIT
          
          cd "$EXTRACT_DIR"
          
          # AppImage is a special ELF file that can be executed with --appimage-extract
          echo "ðŸ”§ Attempting AppImage extraction with --appimage-extract..."
          
          if "$APPIMAGE" --appimage-extract >/dev/null 2>&1; then
            echo "âœ… Extraction successful using --appimage-extract"
          else
            echo "âš ï¸ --appimage-extract failed, trying alternative method..."
            
            # Alternative: AppImage is essentially a .squashfs archive
            if command -v unsquashfs >/dev/null 2>&1; then
              echo "â„¹ï¸ Attempting SquashFS extraction..."
              tail -c +100000 "$APPIMAGE" 2>/dev/null | unsquashfs -d squashfs-root - 2>/dev/null && \
              echo "âœ… SquashFS extraction successful" || echo "âš ï¸ SquashFS extraction failed"
            else
              echo "âš ï¸ unsquashfs not available"
            fi
          fi
          
          # Now list all the libraries found
          if [ -d "$EXTRACT_DIR/squashfs-root" ] || [ -n "$(find "$EXTRACT_DIR" -name "*.so*" 2>/dev/null | head -1)" ]; then
            echo ""
            echo "ðŸ“š All libraries included in AppImage:"
            echo "======================================"
            find "$EXTRACT_DIR" -type f \( -name "*.so*" -o -name "*.la" \) 2>/dev/null | sort
            
            # Count different types
            echo ""
            echo "ðŸ“Š Library Statistics:"
            echo "====================="
            SO_COUNT=$(find "$EXTRACT_DIR" -type f -name "*.so*" 2>/dev/null | wc -l)
            LA_COUNT=$(find "$EXTRACT_DIR" -type f -name "*.la" 2>/dev/null | wc -l)
            echo "  Shared objects (.so*): $SO_COUNT"
            echo "  Libtool archives (.la): $LA_COUNT"
            echo "  Total: $((SO_COUNT + LA_COUNT))"
            
            # Get Qt libraries
            QT_LIBS=$(find "$EXTRACT_DIR" -type f -name "libQt*.so*" 2>/dev/null)
            if [ -n "$QT_LIBS" ]; then
              echo ""
              echo "ðŸŽ¨ Qt Libraries:"
              echo "================"
              echo "$QT_LIBS" | sort
            fi
            
            # Get FFmpeg/GStreamer libraries
            MEDIA_LIBS=$(find "$EXTRACT_DIR" -type f \( -name "libav*.so*" -o -name "libsw*.so*" -o -name "libgst*.so*" \) 2>/dev/null)
            if [ -n "$MEDIA_LIBS" ]; then
              echo ""
              echo "ðŸŽ¬ Media Libraries (FFmpeg/GStreamer):"
              echo "======================================"
              echo "$MEDIA_LIBS" | sort
            fi
            
            # Get USB/Device libraries
            USB_LIBS=$(find "$EXTRACT_DIR" -type f \( -name "libusb*.so*" -o -name "libudev*.so*" \) 2>/dev/null)
            if [ -n "$USB_LIBS" ]; then
              echo ""
              echo "ðŸ”Œ USB/Device Libraries:"
              echo "======================="
              echo "$USB_LIBS" | sort
            fi
          else
            echo "âš ï¸ Could not extract AppImage contents"
            echo "Attempting to list AppImage format information..."
            file "$APPIMAGE"
            echo ""
            echo "Checking AppImage ELF headers..."
            readelf -l "$APPIMAGE" 2>/dev/null | head -20 || strings "$APPIMAGE" | head -30
          fi
          
          echo ""
          echo "âœ… AppImage library analysis completed"

      - name: Start persistent container for testing (Shared)
        timeout-minutes: 15
        env:
          HAS_VOLUME_MOUNT: ${{ env.HAS_VOLUME_MOUNT }}
          VOLUME_MOUNT: ${{ env.VOLUME_MOUNT }}
          INSTALL_TYPE: ${{ env.INSTALL_TYPE }}
          DOCKER_IMAGE_SHARED: ${{ env.DOCKER_IMAGE_SHARED }}
          DOCKER_TAG: ${{ env.DOCKER_TAG }}
        run: |
          echo "ðŸ§ª Starting persistent container for all subsequent tests"
          
          # Set environment variable to track container name
          echo "TEST_CONTAINER_NAME=openterface-test-persistent" >> $GITHUB_ENV
          
          # Build docker run command
          DOCKER_RUN_CMD="docker run -d \
            --name openterface-test-persistent \
            -e DISPLAY=:98 \
            -e GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }} \
            -e INSTALL_TYPE=$INSTALL_TYPE \
            -e QT_X11_NO_MITSHM=1 \
            -e QT_QPA_PLATFORM=xcb \
            -e LC_ALL=C.UTF-8 \
            -e LANG=C.UTF-8 \
            --network host \
            --privileged \
            --device /dev/fuse"
          
          # Add volume mount if provided
          if [ -n "$VOLUME_MOUNT" ]; then
            DOCKER_RUN_CMD="$DOCKER_RUN_CMD $VOLUME_MOUNT"
          fi
          
          # Add image
          DOCKER_RUN_CMD="$DOCKER_RUN_CMD $DOCKER_IMAGE_SHARED:$DOCKER_TAG"
          
          echo "Starting container: $DOCKER_RUN_CMD"
          CONTAINER_ID=$(eval $DOCKER_RUN_CMD)
          
          echo "âœ… Container started"
          echo "ðŸ“¦ Container ID: ${CONTAINER_ID:0:12}"
          echo "CONTAINER_ID=$CONTAINER_ID" >> $GITHUB_ENV
          
          # Wait for app to be ready (max 120 seconds)
          echo "â³ Waiting for app to start (monitoring logs, max 120 seconds)..."
          WAIT_TIME=0
          MAX_WAIT=120
          APP_READY=false
          
          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
              if docker logs $CONTAINER_ID 2>&1 | grep -q "ready for testing"; then
                  echo "âœ… App is ready! (detected after ${WAIT_TIME}s)"
                  APP_READY=true
                  break
              fi
              printf "\râ³ Progress: %d/%d seconds" $WAIT_TIME $MAX_WAIT
              sleep 1
              WAIT_TIME=$((WAIT_TIME + 1))
          done
          
          echo ""
          if [ "$APP_READY" = false ]; then
              echo "âš ï¸ 'Ready' message not detected, but container is running"
              echo "Last 20 lines of logs:"
              docker logs $CONTAINER_ID 2>&1 | tail -20 | sed 's/^/  /'
          fi
          
          # Give the container a moment to settle after app startup
          sleep 2
          
          # Verify container is still running (with better diagnostics)
          echo ""
          echo "ðŸ” Verifying container status..."
          echo "Container ID: $CONTAINER_ID"
          
          # Check if container exists and is running
          CONTAINER_STATUS=$(docker inspect -f '{{.State.Running}}' $CONTAINER_ID 2>/dev/null || echo "error")
          echo "Container status check: $CONTAINER_STATUS"
          
          if [ "$CONTAINER_STATUS" = "true" ]; then
              echo "âœ… Container is running and ready for tests"
          else
              echo "âŒ Container not in running state"
              echo "Full container inspection:"
              docker inspect $CONTAINER_ID 2>&1 | head -30 || echo "Container not found"
              echo ""
              echo "Last 30 lines of logs:"
              docker logs $CONTAINER_ID 2>&1 | tail -30 | sed 's/^/  /' || echo "Could not retrieve logs"
              exit 1
          fi
          
          # Display Openterface app logs for troubleshooting
          echo ""
          echo "ðŸ“‹ Openterface App Logs (for troubleshooting):"
          echo "=================================================="
          docker exec $CONTAINER_ID bash -c 'if [ -f /tmp/openterfaceqt.log ]; then echo "Latest 30 lines from /tmp/openterfaceqt.log:"; tail -30 /tmp/openterfaceqt.log; else echo "âš ï¸ Log file not found at /tmp/openterfaceqt.log"; fi' || echo "âš ï¸ Could not retrieve app logs"
          echo "=================================================="
          echo ""

      - name: Test basic container functionality (Shared)
        timeout-minutes: 5
        run: |
          echo "ðŸ§ª Testing basic container functionality on persistent container"
          
          CONTAINER_ID="${{ env.CONTAINER_ID }}"
          
          # Test simple command execution
          echo "ðŸ” Testing simple command execution..."
          docker exec $CONTAINER_ID bash -c '
            echo "âœ… Container can execute commands"
            whoami
            pwd
            echo "User ID:" $(id)
            echo "Environment variables:"
            env | grep -E "HOME|USER|DISPLAY|QT_|GITHUB_TOKEN|INSTALL_TYPE" | head -10
            echo "File system check:"
            ls -la /home/openterface/ | head -5 || echo "Directory not found"
            echo "âœ… Basic functionality test completed"
          '
          
          echo "âœ… Basic container functionality test passed"
     
      - name: Test hardware interface dependencies (Shared)
        timeout-minutes: 5
        run: |
          echo "ðŸ§ª Testing hardware interface dependencies on persistent container"
          
          CONTAINER_ID="${{ env.CONTAINER_ID }}"
          
          # Check system libraries directly
          docker exec $CONTAINER_ID bash -c '
            echo "ðŸ” Checking USB libraries..."
            dpkg -l | grep libusb || echo "No libusb packages found"
            
            echo "ðŸ” Checking udev libraries..."
            dpkg -l | grep libudev || echo "No libudev packages found"
            
            echo "ðŸ” Checking FFmpeg libraries..."
            dpkg -l | grep libav | head -5 || echo "No FFmpeg packages found"
            
            echo "ðŸ” Checking GStreamer..."
            dpkg -l | grep gstreamer | head -5 || echo "No GStreamer packages found"
            
            echo "âœ… Hardware interface dependencies check completed"
          '
      
      - name: GUI screenshot test on persistent container (Shared)
        timeout-minutes: 10
        run: |
          echo "ðŸ§ª Taking screenshots from persistent container"
          
          CONTAINER_ID="${{ env.CONTAINER_ID }}"
          SCREENSHOTS_DIR="screenshots-shared"
          mkdir -p $SCREENSHOTS_DIR
          
          echo "ðŸ“¸ Preparing to take screenshots..."
          
          # Wait for app to fully render
          echo "â³ Waiting 5 seconds for app to render..."
          sleep 5
          
          # Check container status
          if ! docker ps | grep -q $CONTAINER_ID; then
              echo "âŒ Container is no longer running!"
              echo "Last logs:"
              docker logs $CONTAINER_ID 2>&1 | tail -30
              exit 1
          fi
          
          echo "âœ… Container is running"
          
          # Check X11 display
          echo "ðŸ” Checking X11 display..."
          if docker exec $CONTAINER_ID sh -c "DISPLAY=:98 xdpyinfo >/dev/null 2>&1"; then
              echo "âœ… X11 display :98 is available"
          else
              echo "âš ï¸ X11 display check failed"
          fi
          
          # Take screenshot
          echo "ðŸ“· Taking screenshot..."
          timestamp=$(date +"%Y%m%d_%H%M%S")
          container_screenshot="/tmp/screenshot_${timestamp}.jpg"
          screenshot_jpg="$SCREENSHOTS_DIR/openterface_app_${timestamp}.jpg"
          
          if docker exec $CONTAINER_ID sh -c "DISPLAY=:98 import -window root -quality 90 $container_screenshot 2>&1"; then
              echo "âœ… Screenshot created in container"
              
              if docker cp "$CONTAINER_ID:$container_screenshot" "$screenshot_jpg" 2>/dev/null; then
                  echo "âœ… Screenshot copied to host: $screenshot_jpg"
                  
                  # Analyze screenshot
                  if command -v identify >/dev/null 2>&1; then
                      filesize=$(ls -lh "$screenshot_jpg" | awk '{print $5}')
                      dimensions=$(identify "$screenshot_jpg" | awk '{print $3}')
                      echo "ðŸ“Š Screenshot info: $filesize, Dimensions: $dimensions"
                  fi
              else
                  echo "âŒ Failed to copy screenshot"
                  exit 1
              fi
          else
              echo "âŒ Failed to take screenshot"
              
              # Show diagnostics
              echo "ðŸ“‹ Container logs (last 20 lines):"
              docker logs $CONTAINER_ID 2>&1 | tail -20 | sed 's/^/  /'
              exit 1
          fi
          
          # List screenshots
          if [ -d "$SCREENSHOTS_DIR" ]; then
              echo ""
              echo "ðŸ“Š Screenshots generated:"
              ls -lh $SCREENSHOTS_DIR/
          fi
      - name: Display screenshots in summary (Shared)
        if: always()
        env:
          IMGBB_API_KEY: ${{ secrets.IMGBB_API_KEY }}
        run: |
          echo "ðŸ” DEBUG: Starting screenshot summary generation"
          echo "ðŸ“ Checking for screenshots directory..."
          ls -la screenshots-shared/ 2>&1 || echo "Directory not found"
          
          # Start the summary
          echo "# GUI Screenshots - Shared Build (${{ env.INSTALL_TYPE }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Build Type**: Shared Library" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -d "screenshots-shared" ] && [ "$(ls -A screenshots-shared/*.jpg 2>/dev/null)" ]; then
            echo "âœ… Screenshots directory found"
            echo "## Test Results" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            total_jpgs=$(find screenshots-shared/ -name "*.jpg" 2>/dev/null | wc -l)
            content_jpgs=$(find screenshots-shared/ -name "*.jpg" -exec identify -ping -format "%[mean]" {} \; 2>/dev/null | awk -F. '{if($1 > 100) count++} END {print count+0}')
            
            echo "ðŸ“Š Found $total_jpgs screenshots with $content_jpgs containing content"
            
            echo "- **Total Screenshots**: $total_jpgs" >> $GITHUB_STEP_SUMMARY
            echo "- **With Content**: $content_jpgs" >> $GITHUB_STEP_SUMMARY
            
            if [ "$total_jpgs" -gt 0 ]; then
              echo "- **Status**: SUCCESS" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Screenshots" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            chmod +x docker/upload_to_imgbb.sh
            
            screenshot_count=0
            api_key_shown=0
            upload_failed=0
            
            for img in screenshots-shared/*.jpg; do
              if [ -f "$img" ]; then
                filename=$(basename "$img")
                screenshot_count=$((screenshot_count + 1))
                
                artifact_name="screenshot-shared-${screenshot_count}-$(echo "$filename" | sed 's/[^a-zA-Z0-9.-]/_/g')"
                echo "$artifact_name|$img" >> /tmp/screenshot_artifacts_shared.txt
                
                filesize=$(ls -lh "$img" | awk '{print $5}')
                
                # Add basic screenshot info to summary first
                echo "### Screenshot $screenshot_count: $filename" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "**Size:** $filesize" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                
                # Determine if screenshot has content based on file size (more reliable than color analysis)
                actual_size=$(stat -f%z "$img" 2>/dev/null || stat -c%s "$img" 2>/dev/null || echo 0)
                if [ "$actual_size" -gt 50000 ]; then
                  echo "**Status:** âœ… Content detected ($(($actual_size / 1024))KB)" >> $GITHUB_STEP_SUMMARY
                else
                  echo "**Status:** âš ï¸ File generated (size check: $actual_size bytes)" >> $GITHUB_STEP_SUMMARY
                fi
                echo "" >> $GITHUB_STEP_SUMMARY
                
                if [ -n "$IMGBB_API_KEY" ]; then
                  echo "ðŸ“¤ Uploading $filename to ImgBB..."
                  # Capture only the final URL, suppress all debug output
                  UPLOAD_OUTPUT=$(https_proxy="" IMGBB_API_KEY="$IMGBB_API_KEY" timeout 120 ./docker/upload_to_imgbb.sh "$img" 2>&1)
                  
                  # Try multiple extraction patterns to handle different escaping
                  # Pattern 1: Unescaped URLs (https://i.ibb.co/...)
                  UPLOAD_URL=$(echo "$UPLOAD_OUTPUT" | grep -oE 'https://i\.ibb\.co/[^ "]*' | head -1)
                  
                  # Pattern 2: Escaped URLs (https:\/\/i.ibb.co\/...) - use | as sed delimiter to avoid conflicts
                  if [ -z "$UPLOAD_URL" ]; then
                    UPLOAD_URL=$(echo "$UPLOAD_OUTPUT" | grep -oE 'https:\\/\\/i\.ibb\.co\\/[^ "]*' | head -1 | sed 's|\\/|/|g')
                  fi
                  
                  # Pattern 3: IMAGE URL line - use | as sed delimiter
                  if [ -z "$UPLOAD_URL" ]; then
                    UPLOAD_URL=$(echo "$UPLOAD_OUTPUT" | grep "IMAGE URL:" | grep -oE 'https[^ ]*' | sed 's|\\/|/|g' | head -1)
                  fi
                  
                  # Pattern 4: Get the last non-empty line that looks like a URL - use | as sed delimiter
                  if [ -z "$UPLOAD_URL" ]; then
                    UPLOAD_URL=$(echo "$UPLOAD_OUTPUT" | grep -E '^https' | tail -1 | sed 's|\\/|/|g')
                  fi
                  
                  if [ -n "$UPLOAD_URL" ]; then
                    echo "âœ… Upload successful: $UPLOAD_URL"
                    echo "![Screenshot]($UPLOAD_URL)" >> $GITHUB_STEP_SUMMARY
                    echo "" >> $GITHUB_STEP_SUMMARY
                    echo "[View Full Size]($UPLOAD_URL)" >> $GITHUB_STEP_SUMMARY
                    echo "" >> $GITHUB_STEP_SUMMARY
                  else
                    echo "âš ï¸  Upload URL extraction inconclusive for $filename"
                    echo "   Raw output (last 10 lines):"
                    echo "$UPLOAD_OUTPUT" | tail -10 | sed 's|^|   |'
                    # Still try to extract from raw output as fallback
                    echo "   Attempting URL recovery..."
                    FALLBACK_URL=$(echo "$UPLOAD_OUTPUT" | grep -o 'https[^[:space:]]*' | tail -1 | sed 's|\\/|/|g')
                    if [ -n "$FALLBACK_URL" ] && echo "$FALLBACK_URL" | grep -q 'ibb.co'; then
                      echo "   âœ… Recovered URL: $FALLBACK_URL"
                      echo "![Screenshot]($FALLBACK_URL)" >> $GITHUB_STEP_SUMMARY
                      echo "" >> $GITHUB_STEP_SUMMARY
                      echo "[View Full Size]($FALLBACK_URL)" >> $GITHUB_STEP_SUMMARY
                      echo "" >> $GITHUB_STEP_SUMMARY
                    else
                      upload_failed=1
                      echo "âš ï¸ Upload to ImgBB failed - See artifacts for full image" >> $GITHUB_STEP_SUMMARY
                      echo "" >> $GITHUB_STEP_SUMMARY
                    fi
                  fi
                else
                  if [ $api_key_shown -eq 0 ]; then
                    echo "âš ï¸ IMGBB_API_KEY not configured - displaying logs instead" >> $GITHUB_STEP_SUMMARY
                    echo "" >> $GITHUB_STEP_SUMMARY
                    api_key_shown=1
                  fi
                fi
              fi
            done
            
            if [ $upload_failed -eq 1 ] || [ $api_key_shown -eq 1 ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "## ðŸ“¥ Download Screenshots from Artifacts" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Since ImgBB upload is not available, all screenshots are saved as artifacts:" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "- **openterface-gui-screenshots-shared-${{ env.INSTALL_TYPE }}-collection** - All screenshots" >> $GITHUB_STEP_SUMMARY
              echo "- **openterface-gui-screenshots-shared-${{ env.INSTALL_TYPE }}-individual** - Individual images" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## ðŸ“‹ Step Logs" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "See the logs of the **GUI screenshot test using proven script** step for detailed test output." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
          else
            echo "âŒ Screenshots directory not found or empty"
            echo "## No Screenshots Available" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No screenshots were generated during the test. Please check the logs of the **GUI screenshot test using proven script** step for details." >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload individual screenshots (Shared)
        if: always()
        run: |
          echo "ðŸ“¤ Uploading individual screenshots as artifacts"
          
          # Create temp directory for individual screenshots
          mkdir -p /tmp/individual_screenshots
          
          # Upload each screenshot separately if the artifacts list exists
          if [ -f /tmp/screenshot_artifacts_shared.txt ]; then
            while IFS='|' read -r artifact_name img_path; do
              if [ -f "$img_path" ]; then
                # Copy screenshot to temp directory with clean name
                cp "$img_path" "/tmp/individual_screenshots/$(basename "$img_path")"
                echo "Prepared: $img_path -> $artifact_name"
              fi
            done < /tmp/screenshot_artifacts_shared.txt
          fi
          
          # Also upload the full collection as backup
          if [ -d "screenshots-shared" ] && [ "$(ls -A screenshots-shared/*.jpg 2>/dev/null)" ]; then
            echo "ðŸ“ Also creating full screenshots collection"
          fi
      - name: Upload screenshots collection (Shared)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: openterface-gui-screenshots-shared-${{ env.INSTALL_TYPE }}-collection
          path: screenshots-shared/
          if-no-files-found: warn

      - name: Upload individual screenshots as artifacts (Shared)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: openterface-gui-screenshots-shared-${{ env.INSTALL_TYPE }}-individual
          path: /tmp/individual_screenshots/
          if-no-files-found: warn

      - name: Test container with simulated USB devices (Shared)
        timeout-minutes: 5
        run: |
          echo "ðŸ§ª Testing container with simulated USB device access"
          
          # Set up a trap to kill docker containers on timeout or error
          trap 'echo "âš ï¸ Cleanup triggered"; docker ps -aq --filter "name=openterface-usb-test" | xargs -r docker kill 2>/dev/null || true; docker ps -aq --filter "name=openterface-usb-test" | xargs -r docker rm -f 2>/dev/null || true' EXIT
          
          # Run container with privileged access to test USB handling
          timeout -s KILL 240 docker run --rm \
            --privileged \
            --name openterface-usb-test \
            -v /dev:/dev \
            ${{ env.DOCKER_IMAGE_SHARED }}:${{ env.DOCKER_TAG }} \
            bash -c '
              echo "ðŸ” Checking USB device access..."
              ls -la /dev/bus/usb/ 2>/dev/null || echo "No USB devices found"
              
              echo "ðŸ” Checking hidraw devices..."
              ls -la /dev/hidraw* 2>/dev/null || echo "No hidraw devices found"
              
              echo "ðŸ” Checking ttyUSB devices..."
              ls -la /dev/ttyUSB* 2>/dev/null || echo "No ttyUSB devices found"
              
              echo "ðŸ” Testing lsusb command..."
              lsusb || echo "lsusb command failed"
              
              echo "ðŸ” Checking for target Openterface devices..."
              lsusb | grep -E "534d|1a86" || echo "No Openterface devices detected (expected in test environment)"
              
              echo "âœ… USB device access test completed"
            ' || docker kill openterface-usb-test 2>/dev/null || true
      - name: Clean up Docker resources (Shared)
        if: always()
        timeout-minutes: 5
        run: |
          echo "ðŸ§¹ Cleaning up Docker resources (Shared)"
          
          # Kill any hanging containers immediately (don't wait for graceful shutdown)
          echo "1ï¸âƒ£ Force killing all openterface containers..."
          docker ps -aq --filter "name=openterface-" | xargs -r docker kill 2>/dev/null || true
          
          # Wait a moment for kills to take effect
          sleep 1
          
          # Remove test containers (force remove any remaining)
          echo "2ï¸âƒ£ Force removing all openterface containers..."
          docker ps -aq --filter "name=openterface-" | xargs -r docker rm -f 2>/dev/null || true
          
          # Remove test image
          echo "3ï¸âƒ£ Removing test image..."
          docker rmi ${{ env.DOCKER_IMAGE_SHARED }}:${{ env.DOCKER_TAG }} 2>/dev/null || true
          
          # Additional safety: kill any dangling docker processes at OS level
          echo "4ï¸âƒ£ Killing dangling docker processes..."
          pkill -9 -f "docker run.*openterface" 2>/dev/null || true
          pkill -9 -f "screenshot-docker-app.sh" 2>/dev/null || true
          
          # Use killall as well
          killall -9 docker 2>/dev/null || true
          sleep 1
          
          # Verify cleanup
          echo "5ï¸âƒ£ Verifying cleanup..."
          remaining=$(docker ps -aq --filter "name=openterface-" 2>/dev/null | wc -l)
          if [ "$remaining" -gt 0 ]; then
            echo "âš ï¸ Warning: $remaining containers still exist after cleanup"
            docker ps -a --filter "name=openterface-" || true
            echo "âŒ Cleanup incomplete - killing all docker processes..."
            pkill -9 docker 2>/dev/null || true
          else
            echo "âœ… All containers cleaned up successfully"
          fi
  generate-combined-report:
    if: always()
    needs: [build-test-shared]
    runs-on: ubuntu-24.04
    timeout-minutes: 30
    
    steps:
      - name: Emergency cleanup (if build-test-shared hung)
        timeout-minutes: 5
        run: |
          echo "ðŸ›‘ Performing emergency docker cleanup..."
          
          # Kill any zombie containers from previous job
          echo "1ï¸âƒ£ Killing all docker containers..."
          docker ps -aq | xargs -r docker kill 2>/dev/null || true
          
          sleep 1
          
          echo "2ï¸âƒ£ Removing all docker containers..."
          docker ps -aq | xargs -r docker rm -f 2>/dev/null || true
          
          # Kill processes aggressively
          echo "3ï¸âƒ£ Killing docker processes..."
          pkill -9 -f "docker run" 2>/dev/null || true
          pkill -9 -f "docker" 2>/dev/null || true
          
          # More aggressive: kill all bash processes running docker commands
          echo "4ï¸âƒ£ Cleaning up bash subshells..."
          pkill -9 -f "bash.*docker" 2>/dev/null || true
          pkill -9 -f "timeout.*docker" 2>/dev/null || true
          
          sleep 1
          
          # Verify
          remaining=$(docker ps -aq 2>/dev/null | wc -l)
          if [ "$remaining" -gt 0 ]; then
            echo "âš ï¸ $remaining containers still running, attempting more aggressive cleanup..."
            docker ps -aq | while read container; do
              docker kill -s 9 "$container" 2>/dev/null || true
            done
          fi
          
          echo "âœ… Emergency cleanup complete"

      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download shared screenshots
        uses: actions/download-artifact@v4
        with:
          path: all-artifacts/
        continue-on-error: true
        

      - name: Generate comprehensive test report
        run: |
          echo "ðŸ“‹ Generating comprehensive test report"
          
          # Add combined summary
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# ðŸ“‹ Test Report - Shared Build (DEB + AppImage)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“Š Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Process each install type
          for install_type in deb appimage; do
            echo "### $install_type Results" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Check if artifacts exist for this install type
            screenshots_dir="all-artifacts/openterface-gui-screenshots-shared-${install_type}-collection"
            if [ -d "$screenshots_dir" ]; then
              total=$(find "$screenshots_dir" -name "*.jpg" 2>/dev/null | wc -l)
              
              if [ "$total" -gt 0 ]; then
                # Use file size to determine if screenshots have content (more reliable)
                content=$(find "$screenshots_dir" -name "*.jpg" -size +50k 2>/dev/null | wc -l)
                
                if [ "$content" -eq 0 ]; then
                  # Fallback: check if files exist and are not tiny
                  content=$(find "$screenshots_dir" -name "*.jpg" -type f 2>/dev/null | while read f; do
                    size=$(stat -f%z "$f" 2>/dev/null || stat -c%s "$f" 2>/dev/null || echo 0)
                    if [ "$size" -gt 1000 ]; then
                      echo "1"
                    fi
                  done | wc -l)
                fi
                
                if [ "$content" -gt 0 ]; then
                  rate=$(( content * 100 / total ))
                  status="âœ… PASSED"
                else
                  rate=0
                  status="âœ… GENERATED (size verification inconclusive)"
                fi
                
                echo "- **Total Screenshots**: $total" >> $GITHUB_STEP_SUMMARY
                echo "- **With Content**: $content" >> $GITHUB_STEP_SUMMARY
                echo "- **Success Rate**: ${rate}%" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: $status" >> $GITHUB_STEP_SUMMARY
              else
                echo "- **Status**: âŒ FAILED - No screenshots generated" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "- **Status**: â­ï¸ NOT RUN - No screenshots directory found" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          done
          
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "**Generated on**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow**: ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
          echo "**Run ID**: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
          
          echo ""
          echo "âœ… Combined test report generated and added to summary"
      - name: Upload combined test report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: combined-test-report
          path: combined-test-report.md
          if-no-files-found: warn