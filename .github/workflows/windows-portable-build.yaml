name: Build / Openterface Windows portable

on:
  push:
    branches: ["main", "dev"]
    paths:
      - '.github/workflows/windows-portable-build.yaml'
      - 'vcpkg.json'
      - 'CMakeLists.txt'
      - '**/*.bat'
      - '**/*.cpp'
  pull_request:
    branches: ["dev"]
    paths:
      - '.github/workflows/windows-portable-build.yaml'
      - 'vcpkg.json'
      - 'CMakeLists.txt'
      - '**/*.bat'
      - '**/*.cpp'
      - '**/*.h'
  workflow_dispatch:

defaults:
  run:
    shell: cmd

env:
  ARTIFACT: openterfaceQT.windows.amd64.portable.exe
  SOURCE_DIR: ${{ github.workspace }}
  QT_VERSION: 6.6.3
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  VCPKG_DIR: D:\vcpkg
  VCPKG_KEEP_BUILDTREES: 1
  EXTERNAL_MINGW: C:\mingw64
  VCPKG_MAX_CONCURRENCY: 1

jobs:
  build:
    runs-on: windows-2022
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cache Qt Build
        id: cache-qt
        uses: actions/cache@v3
        with:
          path: C:\Qt6
          key: qt-6.6.3-mingw-windows-static-vcpkg
          restore-keys: |
            qt-6.6.3-mingw-windows-static-

      - name: Cache MinGW, Ninja and assembly packages
        id: cache-mingw
        uses: actions/cache@v3
        with:
          path: |
            C:\mingw64
            # cache common Chocolatey libraries and bin so binary tools like ninja, nasm, yasm are preserved across runs
            C:\ProgramData\chocolatey\lib\ninja
            C:\ProgramData\chocolatey\lib\nasm
            C:\ProgramData\chocolatey\lib\yasm
            C:\ProgramData\chocolatey\bin
          # keep a stable cache key so restorations can hit for typical runner snapshots
          key: mingw-ninja-nasm-yasm-static-2025
          restore-keys: |
            mingw-ninja-nasm-yasm-static-

      - name: Cache MSYS2 / MinGW packages
        id: cache-msys2
        uses: actions/cache@v3
        with:
          path: |
            C:\msys64\mingw64
            C:\msys64\usr\bin
            C:\msys64\var\lib\pacman\local
            D:\vcpkg\downloads\tools\msys2
          key: msys2-${{ runner.os }}-mingw64-${{ hashFiles('vcpkg.json') }}-v1
          restore-keys: |
            msys2-${{ runner.os }}-mingw64-

      - name: Cache vcpkg
        id: cache-vcpkg
        uses: actions/cache@v3
        with:
          path: D:\vcpkg
          key: vcpkg-x64-mingw-static-openssl-ffmpeg-zlib-v1
          restore-keys: |
            vcpkg-x64-mingw-static-
              
      - name: Cache FFmpeg Build
        id: cache-ffmpeg
        uses: actions/cache@v3
        with:
          path: D:\vcpkg\installed\x64-mingw-static\lib
          key: ffmpeg-static-${{ runner.os }}-v1
          restore-keys: |
            ffmpeg-static-

      - name: Cache vcpkg binary archives & downloads
        id: cache-vcpkg-archives
        uses: actions/cache@v3
        with:
          path: |
            C:\Users\runneradmin\AppData\Local\vcpkg\archives
            D:\vcpkg\downloads
          key: vcpkg-archives-${{ runner.os }}-${{ hashFiles('vcpkg.json') }}-v1
          restore-keys: |
            vcpkg-archives-${{ runner.os }}-

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install Ninja and MinGW (if not cached)
        if: steps.cache-mingw.outputs.cache-hit != 'true'
        run: |
          echo Installing Ninja...
          choco install ninja -y

          echo Downloading MinGW-w64 static build...
          curl -L -o mingw-w64.zip https://github.com/niXman/mingw-builds-binaries/releases/download/13.2.0-rt_v11-rev1/x86_64-13.2.0-release-win32-seh-ucrt-rt_v11-rev1.7z
          mkdir C:\mingw64_tmp
          7z x mingw-w64.zip -oC:\mingw64_tmp
          move C:\mingw64_tmp\x86_64-13.2.0-release-win32-seh-ucrt-rt_v11-rev1\* C:\mingw64\
          rmdir /s /q C:\mingw64_tmp

          echo Verifying g++...
          set PATH=C:\mingw64\bin;%PATH%
          g++ --version

      - name: Ensure ninja and assembler tools available (cache may restore files but ensure shims exist)
        run: |
          echo "Checking for ninja executable..."
          where ninja || (
            echo "ninja not found on PATH, installing via choco"
            choco install ninja -y
          )

          echo "Checking for nasm executable..."
          where nasm || (
            echo "nasm not found on PATH, installing via choco"
            choco install nasm -y || echo "nasm install failed"
          )

          echo "Checking for yasm executable..."
          where yasm || (
            echo "yasm not found on PATH, installing via choco"
            choco install yasm -y || echo "yasm install failed"
          )

      - name: Setup MSYS2 (use action)
        uses: msys2/setup-msys2@v2
        with:
          update: true


      - name: Install Build Tools
        if: steps.cache-msys2.outputs.cache-hit != 'true'
        run: |
          echo "Updating MSYS2 and installing MinGW-w64 toolchain..."
          C:\msys64\usr\bin\bash.exe -lc "pacman -Syu --noconfirm"
          C:\msys64\usr\bin\bash.exe -lc "pacman -Syu --noconfirm"
          C:\msys64\usr\bin\bash.exe -lc "pacman -S --needed --noconfirm --overwrite=* mingw-w64-x86_64-gcc mingw-w64-x86_64-cmake mingw-w64-x86_64-make mingw-w64-x86_64-libiconv mingw-w64-x86_64-bzip2 mingw-w64-x86_64-xz mingw-w64-x86_64-winpthreads"

          echo "Verifying compiler..."
          set PATH=C:\msys64\mingw64\bin;%PATH%
          g++ --version

      - name: Verify MinGW Static Linking Capability
        run: |
          set PATH=C:\msys64\mingw64\bin;%PATH%
          echo "Testing static compilation with MinGW..."
          echo #include ^<iostream^> > test.cpp
          echo int main() { std::cout ^<^< "Static build OK!" ^<^< std::endl; return 0; } >> test.cpp
          g++ -static -O2 -s -o test.exe test.cpp
          if errorlevel 1 (
            echo "❌ Failed to compile a static C++ program."
            exit /b 1
          )
          test.exe
          if errorlevel 1 (
            echo "❌ Compiled executable failed to run."
            exit /b 1
          )
          echo "✅ MinGW static linking verified successfully."
          echo "Listing all .a libraries in C:\msys64\mingw64\lib:"
          dir C:\msys64\mingw64\lib\*.a
          if not exist "C:\msys64\mingw64\lib\libbz2.a" (
            echo "❌ libbz2.a not found in MinGW lib directory."
            exit /b 1
          )
          echo "✅ libbz2.a verified."
          del test.cpp test.exe


      - name: Install or Update vcpkg (bootstrap only)
        run: |
          echo Cloning or updating vcpkg...
          if not exist "%VCPKG_DIR%\vcpkg.exe" (
            echo "vcpkg.exe not found, cloning vcpkg repo..."
            git clone https://github.com/microsoft/vcpkg.git %VCPKG_DIR%
            cd %VCPKG_DIR%
            git fetch --all --tags || echo "git fetch failed"
            call bootstrap-vcpkg.bat
          ) else (
            echo "%VCPKG_DIR%\vcpkg.exe already exists, updating vcpkg repo"
            cd %VCPKG_DIR%
            git fetch --all --tags || echo "git fetch failed"
            if defined VCPKG_BASELINE (
              git checkout %VCPKG_BASELINE% || git checkout tags/%VCPKG_BASELINE% || echo "git checkout baseline failed"
            ) else (
              git reset --hard origin/HEAD || echo "git reset failed"
            )
            call bootstrap-vcpkg.bat
          )

          cd "%SOURCE_DIR%"
          set VCPKG_LOG_LEVEL=debug
          set VCPKG_DOWNLOADS_RETRIES=5
          set VCPKG_MAX_CONCURRENCY=%VCPKG_MAX_CONCURRENCY%
          echo vcpkg version/loglevel: && "%VCPKG_DIR%\vcpkg.exe" version || echo "could not show vcpkg version"
          call "%VCPKG_DIR%\vcpkg.exe" integrate install
          echo vcpkg installed ports (end) && "%VCPKG_DIR%\vcpkg.exe" list || echo "couldn't list vcpkg packages"

      # vcpkg manifest will install pkgconf (manifest mode), which will create the msys2 root.

      - name: Install vcpkg manifest (zlib, openssl, pkgconf) using MSYS2
        # Run using bash so we can safely use cygpath and a POSIX-style invocation.
        shell: bash
        run: |
          echo "Installing static packages via manifest (vcpkg.json) using vcpkg"
          echo "VCPKG_DIR: $VCPKG_DIR"
          echo "SOURCE_DIR: $SOURCE_DIR"

          # Convert windows paths to MSYS2-friendly unix paths
          MSYS_VCPKG_DIR="$(cygpath -u "$VCPKG_DIR")"
          MSYS_SOURCE_DIR="$(cygpath -u "$SOURCE_DIR")"

          echo "MSYS_VCPKG_DIR: $MSYS_VCPKG_DIR"
          echo "MSYS_SOURCE_DIR: $MSYS_SOURCE_DIR"

          # Prefer invoking vcpkg under MSYS2 if available, otherwise run via cmd
          # NOTE: some vcpkg releases don't accept --manifest-root; run the vcpkg.exe from the vcpkg root
          # but execute it with working directory set to the manifest (SOURCE_DIR). That ensures manifest mode
          # installs into a repo-local vcpkg_installed directory if that's vcpkg's behavior.
          if [ -x "/c/msys64/usr/bin/bash" ]; then
            echo "System MSYS2 detected at /c/msys64/usr/bin/bash"
            # When running under MSYS2, use the vcpkg.exe from its directory but instruct it to use the repository manifest
            if [ -x "$MSYS_VCPKG_DIR/vcpkg.exe" ]; then
              echo "Running vcpkg install FROM the manifest directory: $MSYS_SOURCE_DIR"
              # Retry loop (bash) for network/transient failures when ports fetch from remote git/http locations
              attempts=0
              max_attempts=3
              until [ $attempts -ge $max_attempts ]
              do
                attempts=$((attempts+1))
                (cd "$MSYS_SOURCE_DIR" && "$MSYS_VCPKG_DIR/vcpkg.exe" install --triplet=x64-mingw-static --host-triplet=x64-mingw-static --clean-after-build --recurse --debug) && break
                echo "vcpkg install attempt $attempts failed; sleeping then retrying..."
                sleep $((attempts * 5))
              done
              if [ $attempts -gt $max_attempts ]; then
                echo "vcpkg install failed after $max_attempts attempts"
                exit 1
              fi
            else
              echo "vcpkg.exe not found at $MSYS_VCPKG_DIR; falling back to CMD vcpkg.exe"
              # fallback: call cmd.exe but do a few attempts to avoid a single transient failure failing the run
              attempt=1
              max_attempts=3
              while [ $attempt -le $max_attempts ]
              do
                cmd.exe /C "pushd \"%SOURCE_DIR%\" && \"%VCPKG_DIR%\\vcpkg.exe\" install --triplet=x64-mingw-static --host-triplet=x64-mingw-static --clean-after-build --recurse --debug && popd" && break
                echo "vcpkg (cmd) install attempt $attempt failed; retrying after sleep..."
                attempt=$((attempt+1))
                sleep $((attempt * 5))
              done
              if [ $attempt -gt $max_attempts ]; then
                echo "vcpkg (cmd) install failed after $max_attempts attempts"
                exit 1
              fi
            fi
          else
            echo "System MSYS2 not available. Running vcpkg via cmd.exe from the manifest directory: %SOURCE_DIR%"
            attempt=1
            max_attempts=3
            while [ $attempt -le $max_attempts ]
            do
              cmd.exe /C "pushd \"%SOURCE_DIR%\" && \"%VCPKG_DIR%\\vcpkg.exe\" install --triplet=x64-mingw-static --host-triplet=x64-mingw-static --clean-after-build --recurse --debug && popd" && break
              echo "vcpkg (cmd) install attempt $attempt failed; retrying..."
              attempt=$((attempt+1))
              sleep $((attempt * 5))
            done
            if [ $attempt -gt $max_attempts ]; then
              echo "vcpkg install (cmd) failed after $max_attempts attempts"
              exit 1
            fi
          fi

          echo "vcpkg list (after install):"
          if [ -x "$MSYS_VCPKG_DIR/vcpkg.exe" ]; then
            (cd "$MSYS_SOURCE_DIR" && "$MSYS_VCPKG_DIR/vcpkg.exe" list) || ("$MSYS_VCPKG_DIR/vcpkg.exe" list)
          else
            cmd.exe /C "pushd \"%SOURCE_DIR%\" && \"%VCPKG_DIR%\\vcpkg.exe\" list && popd"
          fi

      - name: Verify vcpkg manifest installation and artifact directory
        shell: cmd
        run: |
          echo "=== Workspace vcpkg.json presence ==="
          if exist "%SOURCE_DIR%\vcpkg.json" (
            echo "vcpkg.json found at %SOURCE_DIR%\vcpkg.json"
            type "%SOURCE_DIR%\vcpkg.json"
          ) else (
            echo "ERROR: vcpkg.json not found at %SOURCE_DIR% -- the manifest install will do nothing"
            dir "%SOURCE_DIR%" || true
            exit /b 1
          )

          echo "=== vcpkg executable and installed list ==="
          if exist "%VCPKG_DIR%\vcpkg.exe" (
            call "%VCPKG_DIR%\vcpkg.exe" version || echo "vcpkg version command failed"
            call "%VCPKG_DIR%\vcpkg.exe" list || echo "vcpkg list failed"
          ) else (
            echo "WARNING: vcpkg.exe not found at %VCPKG_DIR%"
          )

          echo "=== Installed libraries folder check ==="
          echo "Checking possible installed locations ( repo-local vcpkg_installed or central vcpkg installed )"
          set REPO_LIB_DIR=%SOURCE_DIR%\vcpkg_installed\x64-mingw-static\lib
          set CENTRAL_LIB_DIR=%VCPKG_DIR%\installed\x64-mingw-static\lib

          echo REPO_LIB_DIR=%REPO_LIB_DIR%
          echo CENTRAL_LIB_DIR=%CENTRAL_LIB_DIR%

          if exist "%REPO_LIB_DIR%" (
            echo Found repo-local installed libraries at %REPO_LIB_DIR%
            dir "%REPO_LIB_DIR%"
          ) else if exist "%CENTRAL_LIB_DIR%" (
            echo Found central installed libraries at %CENTRAL_LIB_DIR%
            dir "%CENTRAL_LIB_DIR%"
          ) else (
            echo ERROR: No installed libraries found in either %REPO_LIB_DIR% or %CENTRAL_LIB_DIR%
            echo "Hint: vcpkg install may have failed or installed to a different location. Inspect the vcpkg debug output above."
            exit /b 1
          )

      - name: Build Static FFmpeg
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        run: |
          echo "Building static FFmpeg..."
          cd build-script
          call build-static-ffmpeg-windows.bat

      - name: Verify vcpkg static libraries (with debug output)
        run: |
          set VCPKG_MAX_CONCURRENCY=%VCPKG_MAX_CONCURRENCY%
          set LIB_DIR=%VCPKG_DIR%\installed\x64-mingw-static\lib
          set REPO_LIB_DIR=%SOURCE_DIR%\vcpkg_installed\x64-mingw-static\lib
          echo === vcpkg list ===
          if exist "%VCPKG_DIR%\vcpkg.exe" (
            call "%VCPKG_DIR%\vcpkg.exe" list
          ) else (
            echo WARNING: vcpkg.exe not found in %VCPKG_DIR% - skipping vcpkg list
          )
          echo === vcpkg bootstrap/log/version info ===
          if exist "%VCPKG_DIR%\.git" (
            cd "%VCPKG_DIR%" && git rev-parse --short HEAD && git describe --tags --dirty || echo "git info unavailable"
          ) else (
            echo "No git info for vcpkg"
          )
          echo === Looking for installed libs in either central or repo-local paths ===
          echo CENTRAL: %LIB_DIR%
          echo REPO: %REPO_LIB_DIR%
          if exist "%LIB_DIR%" (
            echo Found central installed libs at %LIB_DIR%
            dir "%LIB_DIR%"
          ) else if exist "%REPO_LIB_DIR%" (
            echo Found repo-local installed libs at %REPO_LIB_DIR%
            dir "%REPO_LIB_DIR%"
          ) else (
            echo ERROR: Library folder not found in either %LIB_DIR% or %REPO_LIB_DIR% && exit /b 1
          )
          echo All static libraries present.

      - name: Dump ffmpeg buildtrees folder on failure
        if: failure()
        run: |
          echo Dumping full buildtrees directory for ffmpeg
          dir D:\vcpkg\buildtrees\ffmpeg /s
          echo Done dumping

      - name: Build Qt Statically (if not cached) - using external MinGW
        if: steps.cache-qt.outputs.cache-hit != 'true'
        run: |
          call build-script/build-static-qt-from-source.bat

      - name: Create Build Directory
        run: |
          mkdir "%RUNNER_TEMP%\build"

      - name: Prepare Driver Files
        run: |
          mkdir "%SOURCE_DIR%\drivers\windows"
          copy "driver\windows\*" "%SOURCE_DIR%\drivers\windows\" /Y

      - name: Update Translations (lupdate + lrelease)
        working-directory: ${{ runner.temp }}\build
        run: |
          set PATH=C:\Qt6\bin;C:\mingw64\bin;%PATH%
          if not exist "C:\Qt6\bin\lupdate.exe" ( echo lupdate not found & exit /b 1 )
          C:\Qt6\bin\lupdate.exe "%SOURCE_DIR%\openterfaceQT.pro"
          C:\Qt6\bin\lrelease.exe "%SOURCE_DIR%\openterfaceQT.pro"

      - name: Build Portable Executable with CMake (run from MSYS2; external MinGW compilers)
        working-directory: ${{ runner.temp }}\build
        run: >-
          REM Run the final cmake build inside MSYS2 to use MSYS2 runtime for packaging while ensuring we use the external MinGW toolchain for compilers
          for /f "delims=" %%i in ('dir /b /ad "C:\msys64\usr" 2^>nul') do set MSYS2_DIR=%%i && set MSYS2_PATH=C:\msys64\usr\bin
          if not exist "%MSYS2_PATH%\bash.exe" (
            set PATH=C:\Qt6\bin;%EXTERNAL_MINGW%\bin;%PATH% &&
            cmake -G "Ninja"
              -DCMAKE_BUILD_TYPE=Release
              -DCMAKE_TOOLCHAIN_FILE="C:/vcpkg/scripts/buildsystems/vcpkg.cmake"
              -DVCPKG_TARGET_TRIPLET="x64-mingw-static"
              -DCMAKE_PREFIX_PATH="C:/Qt6"
              -DOPENTERFACE_BUILD_STATIC=ON
              -DCMAKE_C_COMPILER="%EXTERNAL_MINGW%/bin/gcc.exe"
              -DCMAKE_CXX_COMPILER="%EXTERNAL_MINGW%/bin/g++.exe"
              -DCMAKE_RC_COMPILER="%EXTERNAL_MINGW%/bin/windres.exe"
              "%SOURCE_DIR%" &&
            cmake --build . --config Release -- -j2 &&
            for /f "delims=" %F in ('dir /s /b openterfaceQT.exe 2^>nul') do set "EXE=%F" &&
            if not defined EXE (
              echo Build failed: openterfaceQT.exe not found && dir /s /b . && exit /b 1
            ) &&
            echo Checking for DLL dependencies... &&
            %EXTERNAL_MINGW%\bin\objdump.exe -p "%EXE%" | findstr /i "\.dll" >nul && (
              echo ERROR: DLL dependencies detected! &&
              %EXTERNAL_MINGW%\bin\objdump.exe -p "%EXE%" | findstr /i "\.dll" &&
              exit /b 1
            ) || (
              echo OK: No DLL dependencies — fully static.
            ) &&
            %EXTERNAL_MINGW%\bin\strip.exe -s "%EXE%" &&
            mkdir package &&
            copy "%EXE%" package\openterfaceQT-portable.exe
          ) else (
            # Quote the cygpath converted SOURCE_DIR to avoid splitting on spaces
            "%MSYS2_PATH%\bash.exe" -lc "export PATH=/c/Qt6/bin:/c/mingw64/bin:$PATH && cmake -G \"Ninja\" -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=\"/c/vcpkg/scripts/buildsystems/vcpkg.cmake\" -DVCPKG_TARGET_TRIPLET=\"x64-mingw-static\" -DCMAKE_PREFIX_PATH=\"/c/Qt6\" -DOPENTERFACE_BUILD_STATIC=ON -DCMAKE_C_COMPILER=/c/mingw64/bin/gcc.exe -DCMAKE_CXX_COMPILER=/c/mingw64/bin/g++.exe -DCMAKE_RC_COMPILER=/c/mingw64/bin/windres.exe \"$(cygpath -u '%SOURCE_DIR%')\" && cmake --build . --config Release -- -j2 || exit 1"
            "%MSYS2_PATH%\bash.exe" -lc "for f in \$(find . -name \"openterfaceQT.exe\" -print -quit); do EXE=\$f; break; done; if [ -z \"\$EXE\" ]; then echo Build failed: openterfaceQT.exe not found && exit 1; fi; /c/mingw64/bin/objdump -p \"\$EXE\" | grep -i \\\"\\.dll\\\" && (echo ERROR: DLL dependencies detected && /c/mingw64/bin/objdump -p \"\$EXE\" | grep -i \\\"\\.dll\\\" && exit 1) || echo OK: No DLL dependencies; /c/mingw64/bin/strip -s \"\$EXE\"; mkdir -p package; cp \"\$EXE\" package/openterfaceQT-portable.exe"
          )
            -DCMAKE_BUILD_TYPE=Release
            -DCMAKE_TOOLCHAIN_FILE="C:/vcpkg/scripts/buildsystems/vcpkg.cmake"
            -DVCPKG_TARGET_TRIPLET="x64-mingw-static"
            -DCMAKE_PREFIX_PATH="C:/Qt6"
            -DOPENTERFACE_BUILD_STATIC=ON
            -DCMAKE_C_COMPILER="%EXTERNAL_MINGW%/bin/gcc.exe"
            -DCMAKE_CXX_COMPILER="%EXTERNAL_MINGW%/bin/g++.exe"
            -DCMAKE_RC_COMPILER="%EXTERNAL_MINGW%/bin/windres.exe"
            "%SOURCE_DIR%" &&
          cmake --build . --config Release -- -j2 &&
          for /f "delims=" %F in ('dir /s /b openterfaceQT.exe 2^>nul') do set "EXE=%F" &&
          if not defined EXE (
            echo Build failed: openterfaceQT.exe not found && dir /s /b . && exit /b 1
          ) &&
          echo Checking for DLL dependencies... &&
          %EXTERNAL_MINGW%\bin\objdump.exe -p "%EXE%" | findstr /i "\.dll" >nul && (
            echo ERROR: DLL dependencies detected! &&
            %EXTERNAL_MINGW%\bin\objdump.exe -p "%EXE%" | findstr /i "\.dll" &&
            exit /b 1
          ) || (
            echo OK: No DLL dependencies — fully static.
          ) &&
          %EXTERNAL_MINGW%\bin\strip.exe -s "%EXE%" &&
          mkdir package &&
          copy "%EXE%" package\openterfaceQT-portable.exe

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT }}
          path: ${{ runner.temp }}\build\package\openterfaceQT-portable.exe
          if-no-files-found: error