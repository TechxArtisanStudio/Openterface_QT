name: Linux Build

# This workflow depends on pre-built Docker images from build-qt-environments.yml
# Ensure that workflow has been run successfully before running this build

on:
  push:
    branches: ["main", "dev"]
    tags: ["v*"]
  pull_request:
    branches: ["dev"]
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Type of Qt build to use'
        required: true
        default: 'static'
        type: choice
        options:
        - 'dynamic'
        - 'static'
        - 'both'
      architecture:
        description: 'Target architecture to build'
        required: false
        default: 'amd64'
        type: choice
        options:
        - 'amd64'
        - 'arm64'
        - 'both'
      ubuntu_version:
        description: 'Ubuntu base image version'
        required: false
        default: '24.04'
        type: choice
        options:
        - '22.04'
        - '24.04'

env:
  ARTIFACT: openterfaceQT
  SOURCE_DIR: ${{ github.workspace }}
  QT_VERSION: 6.6.3
  REGISTRY: ghcr.io

jobs:
  build-dynamic:
    if: ${{ github.event.inputs.build_type == 'dynamic' || github.event.inputs.build_type == 'both' || github.event_name != 'workflow_dispatch' }}
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      packages: read
    strategy:
      matrix:
        arch: ${{ (github.event.inputs.architecture == 'both' || github.event.inputs.architecture == '') && fromJSON('["amd64", "arm64"]') || fromJSON(format('["{0}"]', github.event.inputs.architecture || 'amd64')) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set lowercase image name
        run: echo "IMAGE_NAME_LOWER=$(echo '${{ github.repository_owner }}/openterface-qtbuild' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Set architecture suffix
        id: arch-suffix
        run: |
          if [[ "${{ matrix.arch }}" == "amd64" ]]; then
            echo "arch_tag_suffix=-amd64" >> $GITHUB_OUTPUT
          elif [[ "${{ matrix.arch }}" == "arm64" ]]; then
            echo "arch_tag_suffix=-arm64" >> $GITHUB_OUTPUT
          else
            echo "arch_tag_suffix=" >> $GITHUB_OUTPUT
          fi
        
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull pre-built Dynamic Qt Docker Image
        run: |
          echo "Pulling pre-built Dynamic Qt Docker image for ${{ matrix.arch }}..."
          
          IMAGE_TAG="ubuntu-${{ github.event.inputs.ubuntu_version || '24.04' }}${{ steps.arch-suffix.outputs.arch_tag_suffix }}"
          echo "Checking for image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}-dynamic:$IMAGE_TAG"
          
          # Set platform for Docker pull based on target architecture
          if [[ "${{ matrix.arch }}" == "arm64" ]]; then
            DOCKER_PLATFORM="--platform linux/arm64"
          else
            DOCKER_PLATFORM="--platform linux/amd64"
          fi
          
          # Check if image exists in registry
          if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}-dynamic:$IMAGE_TAG > /dev/null 2>&1; then
            echo "Pre-built image found, pulling..."
            docker pull $DOCKER_PLATFORM ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}-dynamic:$IMAGE_TAG

            echo "Successfully pulled pre-built Dynamic Qt Docker image for ${{ matrix.arch }}"
          else
            echo "Error: Pre-built Dynamic Qt Docker image not found in registry for ${{ matrix.arch }}"
            echo "Looking for: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}-dynamic:$IMAGE_TAG"
            echo "Please run the 'Build Qt Environments' workflow first to build the required Docker images"
            echo "Workflow URL: https://github.com/${{ github.repository }}/actions/workflows/build-qt-environments.yml"
            exit 1
          fi
          
          # Tag the architecture-specific image as latest for local use
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}-dynamic:$IMAGE_TAG ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}-dynamic:latest
          
          # Verify the image was pulled successfully
          docker images | grep openterface-qtbuild-dynamic || {
            echo "Error: Failed to verify Dynamic Qt Docker image"
            exit 1
          }

      - name: Install packaging tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y rpm

      - name: Get all tags for correct version determination
        working-directory: ${{ github.workspace }}
        run: |
          git fetch --all --tags -f

      - name: Read version from version.h
        id: read_version
        run: |
          VERSION=$(grep -oP '#define APP_VERSION "\K[^"]+' resources/version.h)
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Build in Docker Container (Dynamic Qt)
        run: |
          # Create build directory in host for artifact collection
          mkdir -p ${{ runner.temp }}/build-dynamic
          mkdir -p ${{ runner.temp }}/build-dynamic/config/languages
          mkdir -p ${{ runner.temp }}/build-dynamic/config/keyboards
          
          # Set up emulation for ARM64 if needed
          if [[ "${{ matrix.arch }}" == "arm64" ]]; then
            echo "Setting up QEMU for ARM64 emulation..."
            docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
            DOCKER_PLATFORM="--platform linux/arm64"
          else
            DOCKER_PLATFORM=""
          fi
          
          # Create build script for inside container
          cat > ${{ runner.temp }}/build-script.sh << 'BUILD_EOF'
          #!/bin/bash
          set -e
          
          echo "Building Openterface QT Application (Dynamic Qt) for ${{ matrix.arch }}..."
          
          # Verify Docker environment
          /opt/verify/verify-qt-dynamic.sh || echo "Verification script not found"
          
          # Set up cross-compilation for ARM64
          if [ "${{ matrix.arch }}" = "arm64" ]; then
            echo "Setting up ARM64 cross-compilation..."
            export CC=aarch64-linux-gnu-gcc
            export CXX=aarch64-linux-gnu-g++
            export PKG_CONFIG_PATH=/usr/lib/aarch64-linux-gnu/pkgconfig:$PKG_CONFIG_PATH
            
            # Verify cross-compilation tools
            echo "Verifying ARM64 cross-compilation tools:"
            which aarch64-linux-gnu-gcc aarch64-linux-gnu-g++ || { echo "ARM64 compilers not found"; exit 1; }
            aarch64-linux-gnu-gcc --version | head -1
            
            # Create CMake toolchain file for ARM64 cross-compilation
            cat > /tmp/toolchain.cmake << 'TOOLCHAIN_EOF'
          set(CMAKE_SYSTEM_NAME Linux)
          set(CMAKE_SYSTEM_PROCESSOR aarch64)
          set(CMAKE_C_COMPILER aarch64-linux-gnu-gcc)
          set(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)
          set(CMAKE_FIND_ROOT_PATH /usr/aarch64-linux-gnu)
          set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
          set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
          set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
          set(PKG_CONFIG_EXECUTABLE aarch64-linux-gnu-pkg-config)
          TOOLCHAIN_EOF
            
            CMAKE_TOOLCHAIN="-DCMAKE_TOOLCHAIN_FILE=/tmp/toolchain.cmake"
            QT_PREFIX="/usr/lib/aarch64-linux-gnu/qt6"
            CMAKE_PREFIX_PATH="/usr/lib/aarch64-linux-gnu/cmake:/usr"
          else
            echo "Using native compilation for AMD64..."
            CMAKE_TOOLCHAIN=""
            QT_PREFIX="/usr/lib/x86_64-linux-gnu/qt6"
            CMAKE_PREFIX_PATH="/usr/lib/x86_64-linux-gnu/cmake:/usr"
          fi
          
          # Copy configuration files
          mkdir -p /workspace/build/config/languages
          mkdir -p /workspace/build/config/keyboards
          cp -r config/keyboards/*.json /workspace/build/config/keyboards/ 2>/dev/null || echo "No keyboard configs"
          cp -r config/languages/*.qm /workspace/build/config/languages/ 2>/dev/null || echo "No language files"
          
          # Build with CMake
          cd /workspace/build
          echo "Configuring with CMake..."
          
          cmake $CMAKE_TOOLCHAIN \
                -DCMAKE_BUILD_TYPE=Release \
                -DCMAKE_PREFIX_PATH="$CMAKE_PREFIX_PATH" \
                -DQt6_DIR="$QT_PREFIX/../cmake/Qt6" \
                -DUSE_GSTREAMER_STATIC_PLUGINS=OFF \
                -DCMAKE_VERBOSE_MAKEFILE=ON \
                /workspace/src
          
          echo "Building with CMake..."
          make -j$(nproc) VERBOSE=1
          
          echo "Build completed successfully"
          BUILD_EOF
          
          chmod +x ${{ runner.temp }}/build-script.sh
          
          # Run build in container
          docker run --rm $DOCKER_PLATFORM \
            -v ${{ github.workspace }}:/workspace/src \
            -v ${{ runner.temp }}/build-dynamic:/workspace/build \
            -v ${{ runner.temp }}/build-script.sh:/build-script.sh \
            -w /workspace/src \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}-dynamic:latest \
            /build-script.sh
          
          # Verify build output
          if [ ! -f "${{ runner.temp }}/build-dynamic/openterfaceQT" ]; then
            echo "Error: openterfaceQT binary not found"
            ls -la ${{ runner.temp }}/build-dynamic/
            exit 1
          fi
          
          echo "BUILD_DIR=${{ runner.temp }}/build-dynamic" >> $GITHUB_ENV

      - name: Create deb package (Dynamic)
        working-directory: ${{ runner.temp }}
        run: |
          mkdir -p package-dynamic/DEBIAN
          
          PKG_NAME="${{ env.ARTIFACT }}.linux.${{ matrix.arch }}.dynamic"
          
          sed -e "s/\${VERSION}/${{ env.VERSION }}/g" \
              -e "s/\${ARCH}/${{ matrix.arch }}/g" \
              ${{ github.workspace }}/packaging/debian/control > package-dynamic/DEBIAN/control
          
          mkdir -p package-dynamic/usr/bin
          cp -r ${{ env.BUILD_DIR }}/openterfaceQT package-dynamic/usr/bin

          mkdir -p package-dynamic/usr/share/icons/hicolor/256x256/apps/
          cp ${{ github.workspace }}/images/icon_256.png package-dynamic/usr/share/icons/hicolor/256x256/apps/openterfaceQT.png

          mkdir -p package-dynamic/usr/share/applications/
          cat > package-dynamic/usr/share/applications/openterfaceQT.desktop << EOF
          [Desktop Entry]
          Version=1.0
          Type=Application
          Name=OpenterfaceQT
          Exec=/usr/bin/openterfaceQT
          Icon=openterfaceQT
          Comment=OpenterfaceQT Application
          Categories=Utility;
          EOF

          mv package-dynamic $PKG_NAME
          dpkg-deb --build $PKG_NAME

      - name: Upload artifact (Dynamic deb)
        uses: actions/upload-artifact@v4
        with:
          name: openterfaceQT.linux.${{ matrix.arch }}.dynamic.deb
          path: ${{ runner.temp }}/${{ env.ARTIFACT }}.linux.${{ matrix.arch }}.dynamic.deb
          if-no-files-found: error

      - name: Create rpm package (Dynamic)
        working-directory: ${{ runner.temp }}
        run: |
          mkdir -p rpmbuild-dynamic/{SPECS,SOURCES,BUILD,RPMS,SRPMS}
          
          PKG_NAME="${{ env.ARTIFACT }}.linux.${{ matrix.arch }}.dynamic"
          
          # Copy build output and icon to SOURCES
          cp ${{ env.BUILD_DIR }}/openterfaceQT rpmbuild-dynamic/SOURCES/ || { echo "Failed to copy openterfaceQT!"; exit 1; }
          cp ${{ github.workspace }}/images/icon_256.png rpmbuild-dynamic/SOURCES/ || { echo "Failed to copy icon_256.png!"; exit 1; }
          
          # Debug: Verify files in SOURCES
          ls -lh rpmbuild-dynamic/SOURCES/
          
          # Generate spec file with version and architecture substitutions
          sed -e "s/\${VERSION}/${{ env.VERSION }}/g" \
              -e "s/\${ARCH}/${{ matrix.arch }}/g" \
              ${{ github.workspace }}/packaging/rpm/spec > rpmbuild-dynamic/SPECS/openterfaceqt.spec
          
          # Debug: Show generated spec file
          cat rpmbuild-dynamic/SPECS/openterfaceqt.spec
          
          # Build RPM
          rpmbuild --define "_topdir ${{ runner.temp }}/rpmbuild-dynamic" -bb rpmbuild-dynamic/SPECS/openterfaceqt.spec
          
          # Copy the resulting RPM
          find rpmbuild-dynamic/RPMS -name "*.rpm" -exec cp {} ./$PKG_NAME.rpm \;

      - name: Upload RPM artifact (Dynamic)
        uses: actions/upload-artifact@v4
        with:
          name: openterfaceQT.linux.${{ matrix.arch }}.dynamic.rpm
          path: ${{ runner.temp }}/${{ env.ARTIFACT }}.linux.${{ matrix.arch }}.dynamic.rpm
          if-no-files-found: error

  build-static:
    if: ${{ github.event.inputs.build_type == 'static' || github.event.inputs.build_type == 'both' || github.event_name != 'workflow_dispatch' }}
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      packages: read
    strategy:
      matrix:
        arch: ${{ (github.event.inputs.architecture == 'both' || github.event.inputs.architecture == '') && fromJSON('["amd64", "arm64"]') || fromJSON(format('["{0}"]', github.event.inputs.architecture || 'amd64')) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive


      - name: Set lowercase image name
        run: echo "IMAGE_NAME_LOWER=$(echo '${{ github.repository_owner }}/openterface-qtbuild' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Set architecture suffix
        id: arch-suffix
        run: |
          if [[ "${{ matrix.arch }}" == "amd64" ]]; then
            echo "arch_tag_suffix=-amd64" >> $GITHUB_OUTPUT
          elif [[ "${{ matrix.arch }}" == "arm64" ]]; then
            echo "arch_tag_suffix=-arm64" >> $GITHUB_OUTPUT
          else
            echo "arch_tag_suffix=" >> $GITHUB_OUTPUT
          fi

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull pre-built Static Qt Docker Image
        run: |
          echo "Pulling pre-built Static Qt Docker image for ${{ matrix.arch }}..."
          
          IMAGE_TAG="ubuntu-${{ github.event.inputs.ubuntu_version || '24.04' }}${{ steps.arch-suffix.outputs.arch_tag_suffix }}"
          echo "Checking for image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}-complete:$IMAGE_TAG"
          
          # Set platform for Docker pull based on target architecture
          if [[ "${{ matrix.arch }}" == "arm64" ]]; then
            DOCKER_PLATFORM="--platform linux/arm64"
          else
            DOCKER_PLATFORM="--platform linux/amd64"
          fi
          
          # Check if image exists in registry
          if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}-complete:$IMAGE_TAG > /dev/null 2>&1; then
            echo "Pre-built image found, pulling..."
            docker pull $DOCKER_PLATFORM ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}-complete:$IMAGE_TAG
            echo "Successfully pulled pre-built Static Qt Docker image for ${{ matrix.arch }}"
          else
            echo "Error: Pre-built Static Qt Docker image not found in registry for ${{ matrix.arch }}"
            echo "Looking for: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}-complete:$IMAGE_TAG"
            echo "Please run the 'Build Qt Environments' workflow first to build the required Docker images"
            echo "Workflow URL: https://github.com/${{ github.repository }}/actions/workflows/build-qt-environments.yml"
            exit 1
          fi
          
          # Tag the architecture-specific image as latest for local use
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}-complete:$IMAGE_TAG ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}-complete:latest
          
          # Verify the image was pulled successfully
          docker images | grep openterface-qtbuild-complete || {
            echo "Error: Failed to verify Static Qt Docker image"
            exit 1
          }

      - name: Install packaging tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y rpm

      - name: Get all tags for correct version determination
        working-directory: ${{ github.workspace }}
        run: |
          git fetch --all --tags -f

      - name: Read version from version.h
        id: read_version
        run: |
          VERSION=$(grep -oP '#define APP_VERSION "\K[^"]+' resources/version.h)
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Build in Docker Container (Static Qt)
        run: |
          # Create build directory in host for artifact collection
          mkdir -p ${{ runner.temp }}/build-static
          mkdir -p ${{ runner.temp }}/build-static/config/languages
          mkdir -p ${{ runner.temp }}/build-static/config/keyboards
          
          # Set up emulation for ARM64 if needed
          if [[ "${{ matrix.arch }}" == "arm64" ]]; then
            echo "Setting up QEMU for ARM64 emulation..."
            docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
            DOCKER_PLATFORM="--platform linux/arm64"
          else
            DOCKER_PLATFORM=""
          fi
          
          # Create build script for static linking
          cat > ${{ runner.temp }}/build-static-script.sh << 'STATIC_BUILD_EOF'
          #!/bin/bash
          set -e
          
          echo "Building Openterface QT Application (Static Qt) for ${{ matrix.arch }}..."
          
          # Verify Qt6 static installation
          if [ ! -d '/opt/Qt6' ]; then
            echo "ERROR: Qt6 static installation not found at /opt/Qt6"
            exit 1
          fi
          
          echo "Qt6 static installation found at /opt/Qt6"
          
          # Set up cross-compilation for ARM64
          if [ "${{ matrix.arch }}" = "arm64" ]; then
            echo "Setting up ARM64 cross-compilation for static build..."
            export CC=aarch64-linux-gnu-gcc
            export CXX=aarch64-linux-gnu-g++
            export PKG_CONFIG_PATH=/usr/lib/aarch64-linux-gnu/pkgconfig:$PKG_CONFIG_PATH
            
            # Verify cross-compilation tools
            which aarch64-linux-gnu-gcc aarch64-linux-gnu-g++ || { echo "ARM64 compilers not found"; exit 1; }
            aarch64-linux-gnu-gcc --version | head -1
            
            # Create CMake toolchain file for ARM64
            cat > /tmp/toolchain.cmake << 'TOOLCHAIN_EOF'
          set(CMAKE_SYSTEM_NAME Linux)
          set(CMAKE_SYSTEM_PROCESSOR aarch64)
          set(CMAKE_C_COMPILER aarch64-linux-gnu-gcc)
          set(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)
          set(CMAKE_FIND_ROOT_PATH /usr/aarch64-linux-gnu)
          set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
          set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
          set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
          set(PKG_CONFIG_EXECUTABLE aarch64-linux-gnu-pkg-config)
          TOOLCHAIN_EOF
            
            CMAKE_TOOLCHAIN="-DCMAKE_TOOLCHAIN_FILE=/tmp/toolchain.cmake"
            CMAKE_LIBRARY_PATH="/opt/Qt6/lib:/usr/local/lib:/opt/ffmpeg/lib:/usr/lib/aarch64-linux-gnu"
          else
            echo "Using native compilation for AMD64 static build..."
            CMAKE_TOOLCHAIN=""
            CMAKE_LIBRARY_PATH="/opt/Qt6/lib:/usr/local/lib:/opt/ffmpeg/lib:/usr/lib/x86_64-linux-gnu"
          fi
          
          # Copy configuration files
          mkdir -p /workspace/build/config/languages
          mkdir -p /workspace/build/config/keyboards
          cp -r config/keyboards/*.json /workspace/build/config/keyboards/ 2>/dev/null || echo "No keyboard configs"
          cp -r config/languages/*.qm /workspace/build/config/languages/ 2>/dev/null || echo "No language files"
          
          # Build with CMake for static linking
          cd /workspace/build
          echo "Configuring with CMake for static build..."
          
          # Set environment variables for static linking
          export PKG_CONFIG_PATH="/opt/Qt6/lib/pkgconfig:/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH"
          export CMAKE_PREFIX_PATH="/opt/Qt6:/usr/local:/opt/ffmpeg:/usr"
          export Qt6_DIR="/opt/Qt6/lib/cmake/Qt6"
          
          cmake $CMAKE_TOOLCHAIN \
                -DCMAKE_PREFIX_PATH="/opt/Qt6:/usr/local:/opt/ffmpeg" \
                -DCMAKE_BUILD_TYPE=Release \
                -DBUILD_SHARED_LIBS=OFF \
                -DCMAKE_FIND_LIBRARY_SUFFIXES=".a;.so" \
                -DUSE_FFMPEG_STATIC=ON \
                -DUSE_GSTREAMER_STATIC_PLUGINS=OFF \
                -DFFMPEG_ROOT=/usr/local \
                -DTurboJPEG_ROOT=/usr/local \
                -DORC_ROOT=/opt/orc-static \
                -DCMAKE_LIBRARY_PATH="$CMAKE_LIBRARY_PATH" \
                -DCMAKE_INCLUDE_PATH="/opt/Qt6/include:/usr/local/include:/opt/ffmpeg/include:/usr/include" \
                -DCMAKE_VERBOSE_MAKEFILE=ON \
                /workspace/src
          
          echo "Building with CMake..."
          make -j$(nproc) VERBOSE=1
          
          echo "Static build completed successfully"
          STATIC_BUILD_EOF
          
          chmod +x ${{ runner.temp }}/build-static-script.sh
          
          # Run build in container
          docker run --rm $DOCKER_PLATFORM \
            -v ${{ github.workspace }}:/workspace/src \
            -v ${{ runner.temp }}/build-static:/workspace/build \
            -v ${{ runner.temp }}/build-static-script.sh:/build-script.sh \
            -w /workspace/src \
            --user root \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}-complete:latest \
            /build-script.sh
          
          # Verify build output
          if [ ! -f "${{ runner.temp }}/build-static/openterfaceQT" ]; then
            echo "Error: openterfaceQT binary not found"
            ls -la ${{ runner.temp }}/build-static/
            exit 1
          fi
          
          echo "BUILD_DIR=${{ runner.temp }}/build-static" >> $GITHUB_ENV

      - name: Create deb package (Static)
        working-directory: ${{ runner.temp }}
        run: |
          mkdir -p package-static/DEBIAN
          
          PKG_NAME="${{ env.ARTIFACT }}.linux.${{ matrix.arch }}.static"
          
          sed -e "s/\${VERSION}/${{ env.VERSION }}/g" \
              -e "s/\${ARCH}/${{ matrix.arch }}/g" \
              ${{ github.workspace }}/packaging/debian/control > package-static/DEBIAN/control
          
          mkdir -p package-static/usr/bin
          cp -r ${{ env.BUILD_DIR }}/openterfaceQT package-static/usr/bin

          mkdir -p package-static/usr/share/icons/hicolor/256x256/apps/
          cp ${{ github.workspace }}/images/icon_256.png package-static/usr/share/icons/hicolor/256x256/apps/openterfaceQT.png

          mkdir -p package-static/usr/share/applications/
          cat > package-static/usr/share/applications/openterfaceQT.desktop << EOF
          [Desktop Entry]
          Version=1.0
          Type=Application
          Name=OpenterfaceQT
          Exec=/usr/bin/openterfaceQT
          Icon=openterfaceQT
          Comment=OpenterfaceQT Application
          Categories=Utility;
          EOF

          mv package-static $PKG_NAME
          dpkg-deb --build $PKG_NAME

      - name: Upload artifact (Static deb)
        uses: actions/upload-artifact@v4
        with:
          name: openterfaceQT.linux.${{ matrix.arch }}.static.deb
          path: ${{ runner.temp }}/${{ env.ARTIFACT }}.linux.${{ matrix.arch }}.static.deb
          if-no-files-found: error

      - name: Create rpm package (Static)
        working-directory: ${{ runner.temp }}
        run: |
          mkdir -p rpmbuild-static/{SPECS,SOURCES,BUILD,RPMS,SRPMS}
          
          PKG_NAME="${{ env.ARTIFACT }}.linux.${{ matrix.arch }}.static"
          
          # Copy build output and icon to SOURCES
          cp ${{ env.BUILD_DIR }}/openterfaceQT rpmbuild-static/SOURCES/ || { echo "Failed to copy openterfaceQT!"; exit 1; }
          cp ${{ github.workspace }}/images/icon_256.png rpmbuild-static/SOURCES/ || { echo "Failed to copy icon_256.png!"; exit 1; }
          
          # Debug: Verify files in SOURCES
          ls -lh rpmbuild-static/SOURCES/
          
          # Generate spec file with version and architecture substitutions
          sed -e "s/\${VERSION}/${{ env.VERSION }}/g" \
              -e "s/\${ARCH}/${{ matrix.arch }}/g" \
              ${{ github.workspace }}/packaging/rpm/spec > rpmbuild-static/SPECS/openterfaceqt.spec
          
          # Debug: Show generated spec file
          cat rpmbuild-static/SPECS/openterfaceqt.spec
          
          # Build RPM
          rpmbuild --define "_topdir ${{ runner.temp }}/rpmbuild-static" -bb rpmbuild-static/SPECS/openterfaceqt.spec
          
          # Copy the resulting RPM
          find rpmbuild-static/RPMS -name "*.rpm" -exec cp {} ./$PKG_NAME.rpm \;

      - name: Upload RPM artifact (Static)
        uses: actions/upload-artifact@v4
        with:
          name: openterfaceQT.linux.${{ matrix.arch }}.static.rpm
          path: ${{ runner.temp }}/${{ env.ARTIFACT }}.linux.${{ matrix.arch }}.static.rpm
          if-no-files-found: error