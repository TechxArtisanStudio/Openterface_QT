# TCP Server Protocol Documentation

## Overview
The Openterface QT TCP Server provides a structured protocol for remote control and monitoring. The server uses JSON-based responses for all communications, ensuring consistency and maintainability.

## Server Information
- **Default Port**: 5900 (configurable)
- **Response Format**: JSON
- **Encoding**: UTF-8
- **Response Structure**: Standardized JSON with type, status, timestamp, and data fields

## Response Structure

All responses follow a standardized JSON format:

```json
{
  "type": "response_type",
  "status": "success|error|warning|pending",
  "timestamp": "2026-02-13T13:08:31.635Z",
  "message": "optional message",
  "data": {
    "additional": "response specific data"
  }
}
```

### Response Fields
- **type**: The type of response (image, screen, status, error, unknown)
- **status**: Success, error, warning, or pending
- **timestamp**: ISO 8601 UTC timestamp
- **message**: Optional human-readable message (for errors/warnings)
- **data**: Response-specific payload (optional)

---

## Supported Commands

### 1. Get Last Image (`lastimage`)

Retrieves the last saved image from the system.

**Request:**
```
lastimage
```

**Success Response:**
```json
{
  "type": "image",
  "status": "success",
  "timestamp": "2026-02-13T13:08:31.635Z",
  "data": {
    "size": 45678,
    "format": "raw",
    "content": "base64_encoded_image_data..."
  }
}
```

**Error Response:**
```json
{
  "type": "error",
  "status": "error",
  "timestamp": "2026-02-13T13:08:31.635Z",
  "message": "No image available"
}
```

---

### 2. Get Target Screen (`gettargetscreen`)

Captures the current frame from the multimedia backend (FFmpeg or GStreamer) and returns it as a base64-encoded JPEG image.

**Request:**
```
gettargetscreen
```

**Success Response:**
```json
{
  "type": "screen",
  "status": "success",
  "timestamp": "2026-02-13T13:08:31.635Z",
  "data": {
    "size": 125432,
    "width": 1920,
    "height": 1080,
    "format": "jpeg",
    "encoding": "base64",
    "content": "base64_encoded_jpeg_data..."
  }
}
```

**Error Response:**
```json
{
  "type": "error",
  "status": "error",
  "timestamp": "2026-02-13T13:08:31.635Z",
  "message": "CameraManager not set. Call setCameraManager() first."
}
```

**Possible Error Messages:**
- `CameraManager not set. Call setCameraManager() first.` - Server not initialized with camera manager
- `No frame available from FFmpeg backend - camera may not be running` - FFmpeg capture failed
- `Failed to capture frame from GStreamer backend` - GStreamer capture failed
- `Unknown or unsupported backend` - Backend type not recognized
- `Failed to encode frame as JPEG` - JPEG encoding error

### Backend Support

| Backend | Platform | Status |
|---------|----------|--------|
| FFmpeg | Windows, Linux, macOS | ✅ Supported |
| GStreamer | Linux only | ✅ Supported |
| GStreamer | Windows | ❌ Not Compiled |

---

### 3. Check Status (`checkstatus`)

Queries the server status of the current operation (script execution).

**Request:**
```
checkstatus
```

**Success Response:**
```json
{
  "type": "status",
  "status": "success",
  "timestamp": "2026-02-13T13:08:31.635Z",
  "data": {
    "state": "FINISH|RUNNING|FAIL",
    "message": "optional status details"
  }
}
```

**State Values:**
- `FINISH` - Operation completed successfully
- `RUNNING` - Operation in progress
- `FAIL` - Operation failed

---

### 4. Script Command

Any command that doesn't match the above is treated as a script statement for execution.

**Request:**
```
<script_statement>
```

**Processing:**
1. Command is tokenized by Lexer
2. AST is generated by Parser
3. `syntaxTreeReady()` signal is emitted
4. Response depends on script execution result

---

## Implementation Details

### Frame Capture Mechanisms

#### FFmpeg Backend
- **Method**: Signal-based frame capture
- **Flow**: 
  1. Server connects to `CameraManager::imageCaptured` signal
  2. Fresh frame is stored in `m_currentFrame` (mutex-protected)
  3. On request, retrieved via `getCurrentFrameFromCamera()`
- **Pros**: Always has latest frame available
- **Cons**: Requires continuous camera operation

#### GStreamer Backend (Linux only)
- **Method**: Direct frame capture via `takeImage()`
- **Flow**:
  1. Request triggers `captureFrameFromGStreamer()`
  2. Frame is saved to temp file
  3. Temp file is loaded into QImage
  4. Temp file is immediately deleted
- **Pros**: On-demand capture, controlled resource usage
- **Cons**: Slight delay for temp file I/O

### Frame Encoding Pipeline

For `gettargetscreen` command:

```
QImage (from backend)
    ↓
JPEG Encoding (quality: 90)
    ↓
QBuffer (memory-based)
    ↓
Base64 Encoding
    ↓
JSON Response
    ↓
TCP Send
```

---

## Error Handling

### Server-Level Errors
All server errors return a standardized error response:

```json
{
  "type": "error",
  "status": "error",
  "timestamp": "2026-02-13T13:08:31Z",
  "message": "Detailed error message"
}
```

### Logging
The TCP server logs all major operations to the `opf.server.tcp` category:
- Client connections/disconnections
- Command received
- Frame capture status
- Data transmission size
- Errors and exceptions

Enable debug logging:
```cpp
QLoggingCategory::setFilterRules("opf.server.tcp.debug=true");
```

---

## Client Integration Example

### C++ Client

```cpp
#include <QTcpSocket>
#include <QJsonDocument>
#include <QJsonObject>

void captureScreen() {
    QTcpSocket socket;
    socket.connectToHost("localhost", 5900);
    
    if (socket.waitForConnected(3000)) {
        // Send request
        socket.write("gettargetscreen\n");
        socket.flush();
        
        // Wait for response
        if (socket.waitForReadyRead(5000)) {
            QByteArray response = socket.readAll();
            QJsonDocument doc = QJsonDocument::fromJson(response);
            QJsonObject obj = doc.object();
            
            if (obj["status"].toString() == "success") {
                QString base64Content = obj["data"].toObject()["content"].toString();
                QByteArray jpegData = QByteArray::fromBase64(base64Content.toLatin1());
                // Use JPEG data...
            }
        }
        socket.close();
    }
}
```

### Python Client

```python
import socket
import json
import base64
from PIL import Image
from io import BytesIO

def capture_screen(host='localhost', port=5900):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.connect((host, port))
        
        # Send request
        sock.sendall(b'gettargetscreen\n')
        
        # Receive response
        response = sock.recv(4096 * 1024)  # Adjust buffer as needed
        data = json.loads(response)
        
        if data['status'] == 'success':
            base64_content = data['data']['content']
            jpeg_data = base64.b64decode(base64_content)
            
            # Convert to PIL Image
            image = Image.open(BytesIO(jpeg_data))
            image.show()
```

---

## Performance Considerations

### Frame Size
- **Typical JPEG (90% quality)**: 50-150 KB per frame
- **Full HD (1920x1080)**: ~100-200 KB base64-encoded
- **Bandwidth at 30 FPS**: ~3-6 Mbps

### Response Size Calculation
```
Total size = JSON overhead (200 bytes) + base64 size
Base64 size = (JPEG size / 3) * 4
```

### Threading Model
- **Frame Storage**: Mutex-protected for thread-safety
- **Signal Connection**: `Qt::DirectConnection` for FFmpeg to minimize latency
- **Response Building**: Happens in TCP thread

---

## Initialization Requirements

Before using `gettargetscreen`, ensure the following:

```cpp
// In your MainWindow or Application class
TcpServer* tcpServer = new TcpServer();
CameraManager* cameraManager = new CameraManager();

// REQUIRED: Set the camera manager
tcpServer->setCameraManager(cameraManager);

// Start the server
tcpServer->startServer(5900);
```

Without calling `setCameraManager()`, the server will return:
```json
{
  "type": "error",
  "status": "error",
  "timestamp": "...",
  "message": "CameraManager not set. Call setCameraManager() first."
}
```

---

## Debugging Tips

### Enable Detailed Logging
```cpp
QLoggingCategory::setFilterRules("opf.server.tcp*=true");
```

### Monitor Frame Capture
Check logs for:
- `Frame captured and stored, size: QSize(1920, 1080)`
- `Screen data captured, JPEG size: 125432 bytes`
- `Sending screen data to client`

### Common Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| "CameraManager not set" | Server not initialized | Call `setCameraManager()` during init |
| "No frame available" | Camera not running | Start video capture first |
| Large response delay | Network bandwidth | Reduce image quality or resolution |
| GStreamer errors on Windows | Platform incompatibility | Use FFmpeg backend on Windows |

---

## Future Enhancements

- [ ] Support for adjustable JPEG quality via request parameters
- [ ] Support for different image formats (PNG, WebP)
- [ ] Streaming mode for continuous frame delivery
- [ ] Client authentication/authorization
- [ ] Response compression (gzip)
- [ ] Batch operations (multiple commands in one request)

